2014-01-09 13:46:28 +0900
target 0: 2.1.1p2 (ruby 2.1.1p2 (2013-12-31 revision 44467) [x86_64-linux]) at "/home/shyouhei/data/target/ruby_2_1/bin/ruby"
target 1: 2.0.0p376 (ruby 2.0.0p376 (2013-12-25 revision 44393) [x86_64-linux]) at "/home/shyouhei/data/target/ruby_2_0_0/bin/ruby"
target 2: 1.9.3p488 (ruby 1.9.3p488 (2013-12-22 revision 44338) [x86_64-linux]) at "/home/shyouhei/data/target/ruby_1_9_3/bin/ruby"
target 3: built-ruby (ruby 2.2.0dev (2014-01-03 trunk 44490) [x86_64-linux]) at "./miniruby -I/home/shyouhei/data/src/ruby.git/lib -I. -I.ext/common  /home/shyouhei/data/src/ruby.git/tool/runruby.rb --extout=.ext  -- --disable-gems"

-----------------------------------------------------------
app_answer

def ack(m, n)
  if m == 0 then
    n + 1
  elsif n == 0 then
    ack(m - 1, 1)
  else
    ack(m - 1, ack(m, n - 1))
  end
end

def the_answer_to_life_the_universe_and_everything
  (ack(3,7).to_s.split(//).inject(0){|s,x| s+x.to_i}.to_s + "2" ).to_i
end

answer = the_answer_to_life_the_universe_and_everything

2.1.1p2	0.07161445
2.1.1p2	0.056695999
2.1.1p2	0.056208697
2.0.0p376	0.067756399
2.0.0p376	0.053703642
2.0.0p376	0.053562691
1.9.3p488	0.062545535
1.9.3p488	0.05263223
1.9.3p488	0.05277262
built-ruby	0.051903595
built-ruby	0.046996281
built-ruby	0.047347993

-----------------------------------------------------------
app_aobench

# AO rebder benchmark
# Original program (C) Syoyo Fujita in Javascript (and other languages)
#      http://lucille.atso-net.jp/blog/?p=642
#      http://lucille.atso-net.jp/blog/?p=711
# Ruby(yarv2llvm) version by Hideki Miura
#

IMAGE_WIDTH = 256
IMAGE_HEIGHT = 256
NSUBSAMPLES = 2
NAO_SAMPLES = 8

class Vec
  def initialize(x, y, z)
    @x = x
    @y = y
    @z = z
  end

  attr_accessor :x, :y, :z

  def vadd(b)
    Vec.new(@x + b.x, @y + b.y, @z + b.z)
  end

  def vsub(b)
    Vec.new(@x - b.x, @y - b.y, @z - b.z)
  end

  def vcross(b)
    Vec.new(@y * b.z - @z * b.y,
            @z * b.x - @x * b.z,
            @x * b.y - @y * b.x)
  end

  def vdot(b)
    @x * b.x + @y * b.y + @z * b.z
  end

  def vlength
    Math.sqrt(@x * @x + @y * @y + @z * @z)
  end

  def vnormalize
    len = vlength
    v = Vec.new(@x, @y, @z)
    if len > 1.0e-17 then
      v.x = v.x / len
      v.y = v.y / len
      v.z = v.z / len
    end
    v
  end
end


class Sphere
  def initialize(center, radius)
    @center = center
    @radius = radius
  end

  attr_reader :center, :radius

  def intersect(ray, isect)
    rs = ray.org.vsub(@center)
    b = rs.vdot(ray.dir)
    c = rs.vdot(rs) - (@radius * @radius)
    d = b * b - c
    if d > 0.0 then
      t = - b - Math.sqrt(d)

      if t > 0.0 and t < isect.t then
        isect.t = t
        isect.hit = true
        isect.pl = Vec.new(ray.org.x + ray.dir.x * t,
                          ray.org.y + ray.dir.y * t,
                          ray.org.z + ray.dir.z * t)
        n = isect.pl.vsub(@center)
        isect.n = n.vnormalize
      else
        0.0
      end
    end
    nil
  end
end

class Plane
  def initialize(p, n)
    @p = p
    @n = n
  end

  def intersect(ray, isect)
    d = -@p.vdot(@n)
    v = ray.dir.vdot(@n)
    v0 = v
    if v < 0.0 then
      v0 = -v
    end
    if v0 < 1.0e-17 then
      return
    end

    t = -(ray.org.vdot(@n) + d) / v

    if t > 0.0 and t < isect.t then
      isect.hit = true
      isect.t = t
      isect.n = @n
      isect.pl = Vec.new(ray.org.x + t * ray.dir.x,
                        ray.org.y + t * ray.dir.y,
                        ray.org.z + t * ray.dir.z)
    end
    nil
  end
end

class Ray
  def initialize(org, dir)
    @org = org
    @dir = dir
  end

  attr_accessor :org, :dir
end

class Isect
  def initialize
    @t = 10000000.0
    @hit = false
    @pl = Vec.new(0.0, 0.0, 0.0)
    @n = Vec.new(0.0, 0.0, 0.0)
  end

  attr_accessor :t, :hit, :pl, :n
end

def clamp(f)
  i = f * 255.5
  if i > 255.0 then
    i = 255.0
  end
  if i < 0.0 then
    i = 0.0
  end
  i.to_i
end

def otherBasis(basis, n)
  basis[2] = Vec.new(n.x, n.y, n.z)
  basis[1] = Vec.new(0.0, 0.0, 0.0)

  if n.x < 0.6 and n.x > -0.6 then
    basis[1].x = 1.0
  elsif n.y < 0.6 and n.y > -0.6 then
    basis[1].y = 1.0
  elsif n.z < 0.6 and n.z > -0.6 then
    basis[1].z = 1.0
  else
    basis[1].x = 1.0
  end

  basis[0] = basis[1].vcross(basis[2])
  basis[0] = basis[0].vnormalize

  basis[1] = basis[2].vcross(basis[0])
  basis[1] = basis[1].vnormalize
end

class Scene
  def initialize
    @spheres = Array.new
    @spheres[0] = Sphere.new(Vec.new(-2.0, 0.0, -3.5), 0.5)
    @spheres[1] = Sphere.new(Vec.new(-0.5, 0.0, -3.0), 0.5)
    @spheres[2] = Sphere.new(Vec.new(1.0, 0.0, -2.2), 0.5)
    @plane = Plane.new(Vec.new(0.0, -0.5, 0.0), Vec.new(0.0, 1.0, 0.0))
  end

  def ambient_occlusion(isect)
    basis = Array.new
    otherBasis(basis, isect.n)

    ntheta    = NAO_SAMPLES
    nphi      = NAO_SAMPLES
    eps       = 0.0001
    occlusion = 0.0

    p0 = Vec.new(isect.pl.x + eps * isect.n.x,
                isect.pl.y + eps * isect.n.y,
                isect.pl.z + eps * isect.n.z)
    nphi.times do |j|
      ntheta.times do |i|
        r = rand
        phi = 2.0 * 3.14159265 * rand
        x = Math.cos(phi) * Math.sqrt(1.0 - r)
        y = Math.sin(phi) * Math.sqrt(1.0 - r)
        z = Math.sqrt(r)

        rx = x * basis[0].x + y * basis[1].x + z * basis[2].x
        ry = x * basis[0].y + y * basis[1].y + z * basis[2].y
        rz = x * basis[0].z + y * basis[1].z + z * basis[2].z

        raydir = Vec.new(rx, ry, rz)
        ray = Ray.new(p0, raydir)

        occisect = Isect.new
        @spheres[0].intersect(ray, occisect)
        @spheres[1].intersect(ray, occisect)
        @spheres[2].intersect(ray, occisect)
        @plane.intersect(ray, occisect)
        if occisect.hit then
          occlusion = occlusion + 1.0
        else
          0.0
        end
      end
    end

    occlusion = (ntheta.to_f * nphi.to_f - occlusion) / (ntheta.to_f * nphi.to_f)

    Vec.new(occlusion, occlusion, occlusion)
  end

  def render(w, h, nsubsamples)
    cnt = 0
    nsf = nsubsamples.to_f
    h.times do |y|
      w.times do |x|
        rad = Vec.new(0.0, 0.0, 0.0)

        # Subsmpling
        nsubsamples.times do |v|
          nsubsamples.times do |u|

            cnt = cnt + 1
            wf = w.to_f
            hf = h.to_f
            xf = x.to_f
            yf = y.to_f
            uf = u.to_f
            vf = v.to_f

            px = (xf + (uf / nsf) - (wf / 2.0)) / (wf / 2.0)
            py = -(yf + (vf / nsf) - (hf / 2.0)) / (hf / 2.0)

            eye = Vec.new(px, py, -1.0).vnormalize

            ray = Ray.new(Vec.new(0.0, 0.0, 0.0), eye)

            isect = Isect.new
            @spheres[0].intersect(ray, isect)
            @spheres[1].intersect(ray, isect)
            @spheres[2].intersect(ray, isect)
            @plane.intersect(ray, isect)
            if isect.hit then
              col = ambient_occlusion(isect)
              rad.x = rad.x + col.x
              rad.y = rad.y + col.y
              rad.z = rad.z + col.z
            end
          end
        end

        r = rad.x / (nsf * nsf)
        g = rad.y / (nsf * nsf)
        b = rad.z / (nsf * nsf)
        printf("%c", clamp(r))
        printf("%c", clamp(g))
        printf("%c", clamp(b))
      end
      nil
    end

    nil
  end
end

alias printf_orig printf
def printf *args
end

# File.open("ao.ppm", "w") do |fp|
  printf("P6\n")
  printf("%d %d\n", IMAGE_WIDTH, IMAGE_HEIGHT)
  printf("255\n", IMAGE_WIDTH, IMAGE_HEIGHT)
  Scene.new.render(IMAGE_WIDTH, IMAGE_HEIGHT, NSUBSAMPLES)
# end

undef printf
alias printf printf_orig

2.1.1p2	46.180319972
2.1.1p2	47.013529551
2.1.1p2	46.880906602
2.0.0p376	51.768977437
2.0.0p376	51.823987971
2.0.0p376	51.919797698
1.9.3p488	90.466863972
1.9.3p488	91.208989492
1.9.3p488	90.455036927
built-ruby	47.893013053
built-ruby	48.586430475
built-ruby	49.105717176

-----------------------------------------------------------
app_erb

#
# Create many HTML strings with ERB.
#

require 'erb'

data = DATA.read
max = 15_000
title = "hello world!"
content = "hello world!\n" * 10

max.times{
  ERB.new(data).result(binding)
}

__END__

<html>
  <head> <%= title %> </head>
  <body>
    <h1> <%= title %> </h1>
    <p>
      <%= content %>
    </p>
  </body>
</html>

2.1.1p2	1.063233305
2.1.1p2	1.054361609
2.1.1p2	1.074642557
2.0.0p376	1.051766054
2.0.0p376	1.045051676
2.0.0p376	1.044243652
1.9.3p488	1.061223452
1.9.3p488	1.062661017
1.9.3p488	1.063852182
built-ruby	0.994321865
built-ruby	0.979415881
built-ruby	0.968504756

-----------------------------------------------------------
app_factorial

def fact(n)
  if(n > 1)
    n * fact(n-1)
  else
    1
  end
end

100.times {
  fact(5000)
}

2.1.1p2	0.848569184
2.1.1p2	0.841120943
2.1.1p2	0.838159162
2.0.0p376	1.130598327
2.0.0p376	1.132891215
2.0.0p376	1.13561161
1.9.3p488	0.96223453
1.9.3p488	0.9648005
1.9.3p488	0.964433566
built-ruby	0.831117075
built-ruby	0.830480607
built-ruby	0.832716269

-----------------------------------------------------------
app_fib

def fib n
  if n < 3
    1
  else
    fib(n-1) + fib(n-2)
  end
end

fib(34)


2.1.1p2	0.452195343
2.1.1p2	0.450231669
2.1.1p2	0.450500693
2.0.0p376	0.472044455
2.0.0p376	0.466501454
2.0.0p376	0.467884414
1.9.3p488	0.632737834
1.9.3p488	0.632928776
1.9.3p488	0.634119869
built-ruby	0.493996381
built-ruby	0.496056417
built-ruby	0.489163296

-----------------------------------------------------------
app_mandelbrot

require 'complex'

def mandelbrot? z
  i = 0
  while i<100
    i += 1
    z = z * z
    return false if z.abs > 2
  end
  true
end

ary = []

(0..1000).each{|dx|
  (0..1000).each{|dy|
    x = dx / 50.0
    y = dy / 50.0
    c = Complex(x, y)
    ary << c if mandelbrot?(c)
  }
}


2.1.1p2	1.067478392
2.1.1p2	1.058915743
2.1.1p2	1.083456093
2.0.0p376	1.136318324
2.0.0p376	1.128894479
2.0.0p376	1.131092157
1.9.3p488	1.757773868
1.9.3p488	1.761934989
1.9.3p488	1.805504491
built-ruby	1.083697361
built-ruby	1.10629992
built-ruby	1.093600547

-----------------------------------------------------------
app_pentomino

#!/usr/local/bin/ruby
# This program is contributed by Shin Nishiyama


# modified by K.Sasada

NP = 5
ROW = 8 + NP
COL = 8

$p = []
$b = []
$no = 0

def piece(n, a, nb)
  nb.each{|x|
    a[n] = x
    if n == NP-1
      $p << [a.sort]
    else
      nbc=nb.dup
      [-ROW, -1, 1, ROW].each{|d|
        if x+d > 0 and not a.include?(x+d) and not nbc.include?(x+d)
          nbc << x+d
        end
      }
      nbc.delete x
      piece(n+1,a[0..n],nbc)
    end
  }
end

def kikaku(a)
  a.collect {|x| x - a[0]}
end
def ud(a)
  kikaku(a.collect {|x| ((x+NP)%ROW)-ROW*((x+NP)/ROW) }.sort)
end
def rl(a)
  kikaku(a.collect {|x| ROW*((x+NP)/ROW)+ROW-((x+NP)%ROW)}.sort)
end
def xy(a)
  kikaku(a.collect {|x| ROW*((x+NP)%ROW) + (x+NP)/ROW }.sort)
end

def mkpieces
  piece(0,[],[0])
  $p.each do |a|
    a0 = a[0]
    a[1] = ud(a0)
    a[2] = rl(a0)
    a[3] = ud(rl(a0))
    a[4] = xy(a0)
    a[5] = ud(xy(a0))
    a[6] = rl(xy(a0))
    a[7] = ud(rl(xy(a0)))
    a.sort!
    a.uniq!
  end
  $p.uniq!.sort! {|x,y| x[0] <=> y[0] }
end

def mkboard
  (0...ROW*COL).each{|i|
    if i % ROW >= ROW-NP
      $b[i] = -2
    else
      $b[i] = -1
    end
    $b[3*ROW+3]=$b[3*ROW+4]=$b[4*ROW+3]=$b[4*ROW+4]=-2
  }
end

def pboard
  return # skip print
  print "No. #$no\n"
  (0...COL).each{|i|
    print "|"
    (0...ROW-NP).each{|j|
      x = $b[i*ROW+j]
      if x < 0
        print "..|"
      else
        printf "%2d|",x+1
      end
    }
    print "\n"
  }
  print "\n"
end

$pnum=[]
def setpiece(a,pos)
  if a.length == $p.length then
    $no += 1
    pboard
    return
  end
  while $b[pos] != -1
    pos += 1
  end
  ($pnum - a).each do |i|
    $p[i].each do |x|
      f = 0
      x.each{|s|
        if $b[pos+s] != -1
          f=1
          break
        end
      }
      if f == 0 then
        x.each{|s|
          $b[pos+s] = i
        }
        a << i
        setpiece(a.dup, pos)
        a.pop
        x.each{|s|
          $b[pos+s] = -1
        }
      end
    end
  end
end

mkpieces
mkboard
$p[4] = [$p[4][0]]
$pnum = (0...$p.length).to_a
setpiece([],0)


__END__

# original

NP = 5
ROW = 8 + NP
COL = 8

$p = []
$b = []
$no = 0

def piece(n,a,nb)
  for x in nb
    a[n] = x
    if n == NP-1
      $p << [a.sort]
    else
      nbc=nb.dup
      for d in [-ROW, -1, 1, ROW]
        if x+d > 0 and not a.include?(x+d) and not nbc.include?(x+d)
          nbc << x+d
        end
      end
      nbc.delete x
      piece(n+1,a[0..n],nbc)
    end
  end
end

def kikaku(a)
  a.collect {|x| x - a[0]}
end
def ud(a)
  kikaku(a.collect {|x| ((x+NP)%ROW)-ROW*((x+NP)/ROW) }.sort)
end
def rl(a)
  kikaku(a.collect {|x| ROW*((x+NP)/ROW)+ROW-((x+NP)%ROW)}.sort)
end
def xy(a)
  kikaku(a.collect {|x| ROW*((x+NP)%ROW) + (x+NP)/ROW }.sort)
end

def mkpieces
  piece(0,[],[0])
  $p.each do |a|
    a0 = a[0]
    a[1] = ud(a0)
    a[2] = rl(a0)
    a[3] = ud(rl(a0))
    a[4] = xy(a0)
    a[5] = ud(xy(a0))
    a[6] = rl(xy(a0))
    a[7] = ud(rl(xy(a0)))
    a.sort!
    a.uniq!
  end
  $p.uniq!.sort! {|x,y| x[0] <=> y[0] }
end

def mkboard
  for i in 0...ROW*COL
    if i % ROW >= ROW-NP
      $b[i] = -2
    else
      $b[i] = -1
    end
    $b[3*ROW+3]=$b[3*ROW+4]=$b[4*ROW+3]=$b[4*ROW+4]=-2
  end
end

def pboard
  print "No. #$no\n"
  for i in 0...COL
    print "|"
    for j in 0...ROW-NP
      x = $b[i*ROW+j]
      if x < 0
        print "..|"
      else
        printf "%2d|",x+1
      end
    end
    print "\n"
  end
  print "\n"
end

$pnum=[]
def setpiece(a,pos)
  if a.length == $p.length then
    $no += 1
    pboard
    return
  end
  while $b[pos] != -1
    pos += 1
  end
  ($pnum - a).each do |i|
    $p[i].each do |x|
      f = 0
      for s in x do
        if $b[pos+s] != -1
          f=1
          break
        end
      end
      if f == 0 then
        for s in x do
          $b[pos+s] = i
        end
        a << i
        setpiece(a.dup, pos)
        a.pop
        for s in x do
          $b[pos+s] = -1
        end
      end
    end
  end
end

mkpieces
mkboard
$p[4] = [$p[4][0]]
$pnum = (0...$p.length).to_a
setpiece([],0)

2.1.1p2	15.995002055
2.1.1p2	16.055379777
2.1.1p2	16.044610017
2.0.0p376	16.292415654
2.0.0p376	16.171820372
2.0.0p376	16.199375931
1.9.3p488	16.303151904
1.9.3p488	16.164081259
1.9.3p488	16.290488878
built-ruby	16.397066988
built-ruby	16.437248011
built-ruby	16.530455574

-----------------------------------------------------------
app_raise

i = 0
while i<300000
  i += 1
  begin
    raise
  rescue
  end
end

2.1.1p2	0.357093104
2.1.1p2	0.33194047
2.1.1p2	0.33188944
2.0.0p376	0.291463937
2.0.0p376	0.291419411
2.0.0p376	0.294647499
1.9.3p488	0.440765794
1.9.3p488	0.428953317
1.9.3p488	0.437773828
built-ruby	0.339349344
built-ruby	0.341979158
built-ruby	0.341383866

-----------------------------------------------------------
app_strconcat

i = 0
while i<2_000_000
  "#{1+1} #{1+1} #{1+1}"
  i += 1
end

2.1.1p2	1.285189545
2.1.1p2	1.261374515
2.1.1p2	1.298565928
2.0.0p376	1.203356007
2.0.0p376	1.227771628
2.0.0p376	1.211296518
1.9.3p488	1.341268823
1.9.3p488	1.353948404
1.9.3p488	1.342560453
built-ruby	1.252123552
built-ruby	1.262034143
built-ruby	1.254783751

-----------------------------------------------------------
app_tak


def tak x, y, z
  unless y < x
    z
  else
    tak( tak(x-1, y, z),
         tak(y-1, z, x),
         tak(z-1, x, y))
  end
end

tak(18, 9, 0)


2.1.1p2	0.681942297
2.1.1p2	0.656916703
2.1.1p2	0.665664502
2.0.0p376	0.678022839
2.0.0p376	0.680031009
2.0.0p376	0.68248588
1.9.3p488	0.959567017
1.9.3p488	0.952134896
1.9.3p488	0.951633643
built-ruby	0.721588707
built-ruby	0.699397175
built-ruby	0.707075357

-----------------------------------------------------------
app_tarai

def tarai( x, y, z )
  if x <= y
  then y
  else tarai(tarai(x-1, y, z),
             tarai(y-1, z, x),
             tarai(z-1, x, y))
  end
end

tarai(12, 6, 0)

2.1.1p2	0.552609179
2.1.1p2	0.548298297
2.1.1p2	0.541099116
2.0.0p376	0.567492216
2.0.0p376	0.569595295
2.0.0p376	0.573119809
1.9.3p488	0.76568104
1.9.3p488	0.753496201
1.9.3p488	0.755686649
built-ruby	0.579698914
built-ruby	0.581843772
built-ruby	0.597094004

-----------------------------------------------------------
app_uri

require 'uri'

100_000.times{
  uri = URI.parse('http://www.ruby-lang.org')
  uri.scheme
  uri.host
  uri.port
}

2.1.1p2	0.673334885
2.1.1p2	0.681709478
2.1.1p2	0.671267009
2.0.0p376	0.724293293
2.0.0p376	0.711662347
2.0.0p376	0.711214659
1.9.3p488	0.64775252
1.9.3p488	0.635366347
1.9.3p488	0.635767108
built-ruby	0.65945548
built-ruby	0.660747279
built-ruby	0.659292316

-----------------------------------------------------------
hash_flatten

h = {}

10000.times do |i|
  h[i] = nil
end

1000.times do
  h.flatten
end

2.1.1p2	0.676942177
2.1.1p2	0.678966748
2.1.1p2	0.692348241
2.0.0p376	2.996892543
2.0.0p376	2.98562122
2.0.0p376	3.009410585
1.9.3p488	3.093214421
1.9.3p488	3.085934919
1.9.3p488	3.096551174
built-ruby	0.659766687
built-ruby	0.665606795
built-ruby	0.661024192

-----------------------------------------------------------
hash_keys

h = {}

10000.times do |i|
  h[i] = nil
end

5000.times do
  h.keys
end

2.1.1p2	0.307380552
2.1.1p2	0.301255109
2.1.1p2	0.300064774
2.0.0p376	3.131493429
2.0.0p376	3.132781908
2.0.0p376	3.135714786
1.9.3p488	3.017040395
1.9.3p488	3.015491366
1.9.3p488	3.033873313
built-ruby	0.290420019
built-ruby	0.289518501
built-ruby	0.292021247

-----------------------------------------------------------
hash_shift

h = {}

10000.times do |i|
  h[i] = nil
end

50000.times do
  k, v = h.shift
  h[k] = v
end

2.1.1p2	0.044521522
2.1.1p2	0.044151167
2.1.1p2	0.044357052
2.0.0p376	4.91929007
2.0.0p376	5.9257935
2.0.0p376	5.982457902
1.9.3p488	0.030041822
1.9.3p488	0.030104515
1.9.3p488	0.029793729
built-ruby	0.03249117
built-ruby	0.032224895
built-ruby	0.032618757

-----------------------------------------------------------
hash_values

h = {}

10000.times do |i|
  h[i] = nil
end

5000.times do
  h.values
end

2.1.1p2	0.298060113
2.1.1p2	0.298946174
2.1.1p2	0.297877631
2.0.0p376	3.111033106
2.0.0p376	3.098875485
2.0.0p376	3.129539484
1.9.3p488	2.999499302
1.9.3p488	3.046080582
1.9.3p488	3.026596242
built-ruby	0.29573617
built-ruby	0.283734572
built-ruby	0.284149398

-----------------------------------------------------------
io_file_create

#
# Create files
#

max = 200_000
file = './tmpfile_of_bm_io_file_create'

max.times{
  f = open(file, 'w')
  f.close#(true)
}
File.unlink(file)


2.1.1p2	2.084113952
2.1.1p2	2.045791308
2.1.1p2	2.07894159
2.0.0p376	1.884557194
2.0.0p376	1.931733403
2.0.0p376	1.912010711
1.9.3p488	1.876735958
1.9.3p488	1.870241223
1.9.3p488	1.895507575
built-ruby	1.911648278
built-ruby	1.932849481
built-ruby	1.912759656

-----------------------------------------------------------
io_file_read

#
# Seek and Read file.
#

require 'tempfile'

max = 200_000
str = "Hello world!  " * 1000
f = Tempfile.new('yarv-benchmark')
f.write str

max.times{
  f.seek 0
  f.read
}

2.1.1p2	1.075080484
2.1.1p2	1.034462944
2.1.1p2	1.164349082
2.0.0p376	2.104899623
2.0.0p376	2.122485171
2.0.0p376	2.128855883
1.9.3p488	2.12885553
1.9.3p488	2.219270126
1.9.3p488	2.159325741
built-ruby	1.005803636
built-ruby	0.995624974
built-ruby	0.993127872

-----------------------------------------------------------
io_file_write

#
# Seek and Write file.
#

require 'tempfile'

max = 200_000
str = "Hello world!  " * 1000
f = Tempfile.new('yarv-benchmark')

max.times{
  f.seek 0
  f.write str
}

2.1.1p2	0.870453123
2.1.1p2	0.859926865
2.1.1p2	0.870971417
2.0.0p376	0.845280235
2.0.0p376	0.846731398
2.0.0p376	0.864715575
1.9.3p488	0.805428507
1.9.3p488	0.815632428
1.9.3p488	0.810791401
built-ruby	0.856652809
built-ruby	0.901546811
built-ruby	0.861546362

-----------------------------------------------------------
io_select

# IO.select performance

w = [ IO.pipe[1] ];

nr = 1000000
nr.times {
  IO.select nil, w
}


2.1.1p2	1.264363964
2.1.1p2	1.262544642
2.1.1p2	1.270771677
2.0.0p376	1.225958135
2.0.0p376	1.223318471
2.0.0p376	1.228220427
1.9.3p488	1.106577363
1.9.3p488	1.101158537
1.9.3p488	1.098293115
built-ruby	1.223211389
built-ruby	1.230193013
built-ruby	1.228985774

-----------------------------------------------------------
io_select2

# IO.select performance. worst case of single fd.

ios = []
nr = 1000000
if defined?(Process::RLIMIT_NOFILE)
  max = Process.getrlimit(Process::RLIMIT_NOFILE)[0]
else
  max = 64
end
puts "max fd: #{max} (results not apparent with <= 1024 max fd)"

((max / 2) - 10).times do
  ios.concat IO.pipe
end

last = [ ios[-1] ]
puts "last IO: #{last[0].inspect}"

nr.times do
  IO.select nil, last
end


2.1.1p2	1.432572655
2.1.1p2	1.432579402
2.1.1p2	1.431788357
2.0.0p376	1.384076772
2.0.0p376	1.403502155
2.0.0p376	1.391903089
1.9.3p488	1.280592686
1.9.3p488	1.375832291
1.9.3p488	1.274943212
built-ruby	1.396680973
built-ruby	1.381019534
built-ruby	1.384775247

-----------------------------------------------------------
io_select3

# IO.select performance. a lot of fd

ios = []
nr = 100
if defined?(Process::RLIMIT_NOFILE)
  max = Process.getrlimit(Process::RLIMIT_NOFILE)[0]
else
  max = 64
end
puts "max fd: #{max} (results not apparent with <= 1024 max fd)"

(max - 10).times do
  r, w = IO.pipe
  r.close
  ios.push w
end

nr.times do
  IO.select nil, ios
end


2.1.1p2	0.038069908
2.1.1p2	0.037329258
2.1.1p2	0.037066111
2.0.0p376	0.034822925
2.0.0p376	0.035453498
2.0.0p376	0.035481918
1.9.3p488	0.023484455
1.9.3p488	0.023609168
1.9.3p488	0.022964358
built-ruby	0.025406822
built-ruby	0.02487105
built-ruby	0.025151997

-----------------------------------------------------------
loop_for

for i in 1..30_000_000
  #
end

2.1.1p2	1.264983996
2.1.1p2	1.205215452
2.1.1p2	1.19201663
2.0.0p376	1.214261742
2.0.0p376	1.228141685
2.0.0p376	1.255142715
1.9.3p488	1.297169712
1.9.3p488	1.312113978
1.9.3p488	1.298199031
built-ruby	1.220279195
built-ruby	1.217505769
built-ruby	1.218888754

-----------------------------------------------------------
loop_generator

max = 600000

if defined? Fiber
  gen = (1..max).each
  loop do
    gen.next
  end
else
  require 'generator'
  gen = Generator.new((0..max))
  while gen.next?
    gen.next
  end
end

2.1.1p2	0.417006864
2.1.1p2	0.413154432
2.1.1p2	0.414459501
2.0.0p376	0.415401364
2.0.0p376	0.414662839
2.0.0p376	0.412945003
1.9.3p488	0.412258619
1.9.3p488	0.412432431
1.9.3p488	0.409762937
built-ruby	0.406731
built-ruby	0.411253807
built-ruby	0.409545618

-----------------------------------------------------------
loop_times

30_000_000.times{|e|}

2.1.1p2	1.101816848
2.1.1p2	1.100772321
2.1.1p2	1.098617932
2.0.0p376	1.132467082
2.0.0p376	1.112714424
2.0.0p376	1.113407555
1.9.3p488	1.233724689
1.9.3p488	1.169472139
1.9.3p488	1.170214328
built-ruby	1.197629936
built-ruby	1.17879239
built-ruby	1.134669035

-----------------------------------------------------------
loop_whileloop

i = 0
while i<30_000_000 # benchmark loop 1
  i += 1
end

2.1.1p2	0.60555732
2.1.1p2	0.60264823
2.1.1p2	0.604484804
2.0.0p376	0.620912262
2.0.0p376	0.620958468
2.0.0p376	0.621653348
1.9.3p488	0.619166145
1.9.3p488	0.61874923
1.9.3p488	0.618302698
built-ruby	0.596915708
built-ruby	0.604007585
built-ruby	0.596523258

-----------------------------------------------------------
loop_whileloop2

i = 0
while i< 6_000_000 # benchmark loop 2
  i += 1
end

2.1.1p2	0.141377557
2.1.1p2	0.13972336
2.1.1p2	0.139450299
2.0.0p376	0.140181324
2.0.0p376	0.140327641
2.0.0p376	0.141528063
1.9.3p488	0.13718052
1.9.3p488	0.131704421
1.9.3p488	0.131385137
built-ruby	0.129041065
built-ruby	0.130931998
built-ruby	0.129792427

-----------------------------------------------------------
so_ackermann

#!/usr/bin/ruby
# -*- mode: ruby -*-
# $Id: ackermann-ruby.code,v 1.4 2004/11/13 07:40:41 bfulgham Exp $
# http://www.bagley.org/~doug/shootout/

def ack(m, n)
    if m == 0 then
        n + 1
    elsif n == 0 then
        ack(m - 1, 1)
    else
        ack(m - 1, ack(m, n - 1))
    end
end

NUM = 9
ack(3, NUM)



2.1.1p2	0.555733106
2.1.1p2	0.549695358
2.1.1p2	0.554712228
2.0.0p376	0.578662368
2.0.0p376	0.58258555
2.0.0p376	0.58248392
1.9.3p488	0.724386891
1.9.3p488	0.723351486
1.9.3p488	0.726466857
built-ruby	0.592565876
built-ruby	0.600503542
built-ruby	0.595485997

-----------------------------------------------------------
so_array

#!/usr/bin/ruby
# -*- mode: ruby -*-
# $Id: ary-ruby.code,v 1.4 2004/11/13 07:41:27 bfulgham Exp $
# http://www.bagley.org/~doug/shootout/
# with help from Paul Brannan and Mark Hubbart

n = 9000 # Integer(ARGV.shift || 1)

x = Array.new(n)
y = Array.new(n, 0)

n.times{|bi|
  x[bi] = bi + 1
}

(0 .. 999).each do |e|
  (n-1).step(0,-1) do |bi|
    y[bi] += x.at(bi)
  end
end
# puts "#{y.first} #{y.last}"



2.1.1p2	0.826826781
2.1.1p2	0.828740791
2.1.1p2	0.842492361
2.0.0p376	1.024685809
2.0.0p376	1.003268905
2.0.0p376	1.01223902
1.9.3p488	1.238463353
1.9.3p488	1.251710208
1.9.3p488	1.245088834
built-ruby	0.8626811
built-ruby	0.861685777
built-ruby	0.882931192

-----------------------------------------------------------
so_binary_trees

# The Computer Language Shootout Benchmarks
# http://shootout.alioth.debian.org
#
# contributed by Jesse Millikan

# disable output
alias puts_orig puts
def puts str
  # disable puts
end

def item_check(tree)
 if tree[0] == nil
  tree[1]
 else
  tree[1] + item_check(tree[0]) - item_check(tree[2])
 end
end

def bottom_up_tree(item, depth)
 if depth > 0
  item_item = 2 * item
  depth -= 1
  [bottom_up_tree(item_item - 1, depth), item, bottom_up_tree(item_item, depth)]
 else
  [nil, item, nil]
 end
end

max_depth = 16 # ARGV[0].to_i
min_depth = 4

max_depth = min_depth + 2 if min_depth + 2 > max_depth

stretch_depth = max_depth + 1
stretch_tree = bottom_up_tree(0, stretch_depth)

puts "stretch tree of depth #{stretch_depth}\t check: #{item_check(stretch_tree)}"
stretch_tree = nil

long_lived_tree = bottom_up_tree(0, max_depth)

min_depth.step(max_depth + 1, 2) do |depth|
 iterations = 2**(max_depth - depth + min_depth)

 check = 0

 for i in 1..iterations
  temp_tree = bottom_up_tree(i, depth)
  check += item_check(temp_tree)

  temp_tree = bottom_up_tree(-i, depth)
  check += item_check(temp_tree)
 end

 puts "#{iterations * 2}\t trees of depth #{depth}\t check: #{check}"
end

puts "long lived tree of depth #{max_depth}\t check: #{item_check(long_lived_tree)}"

undef puts
alias puts puts_orig

2.1.1p2	5.936390596
2.1.1p2	5.888435169
2.1.1p2	5.889338682
2.0.0p376	6.484615168
2.0.0p376	6.443247128
2.0.0p376	6.484145267
1.9.3p488	7.936166118
1.9.3p488	7.908431049
1.9.3p488	7.928245062
built-ruby	6.293140654
built-ruby	6.273179398
built-ruby	6.318781854

-----------------------------------------------------------
so_concatenate

#!/usr/bin/ruby
# -*- mode: ruby -*-
# $Id: strcat-ruby.code,v 1.4 2004/11/13 07:43:28 bfulgham Exp $
# http://www.bagley.org/~doug/shootout/
# based on code from Aristarkh A Zagorodnikov and Dat Nguyen

STUFF = "hello\n"
i = 0
while i<10
  i += 1
  hello = ''
  4_000_000.times do |e|
    hello << STUFF
  end
end
# puts hello.length



2.1.1p2	4.240087236
2.1.1p2	4.331015265
2.1.1p2	4.274741422
2.0.0p376	3.71331407
2.0.0p376	3.754861267
2.0.0p376	3.884712726
1.9.3p488	3.889846121
1.9.3p488	3.84248544
1.9.3p488	3.832180389
built-ruby	4.447907092
built-ruby	4.434787722
built-ruby	4.498798001

-----------------------------------------------------------
so_count_words

#!/usr/bin/ruby
# -*- mode: ruby -*-
# $Id: wc-ruby.code,v 1.4 2004/11/13 07:43:32 bfulgham Exp $
# http://www.bagley.org/~doug/shootout/
# with help from Paul Brannan

input = open(File.join(File.dirname($0), 'wc.input'), 'rb')

nl = nw = nc = 0
while true
  tmp = input.read(4096) or break
  data = tmp << (input.gets || "")
  nc += data.length
  nl += data.count("\n")
  ((data.strip! || data).tr!("\n", " ") || data).squeeze!
  nw += data.count(" ") + 1
end
# STDERR.puts "#{nl} #{nw} #{nc}"


2.1.1p2	0.246779318
2.1.1p2	0.23322264
2.1.1p2	0.232460807
2.0.0p376	0.237323331
2.0.0p376	0.233553006
2.0.0p376	0.230535182
1.9.3p488	0.229639066
1.9.3p488	0.227008724
1.9.3p488	0.22751194
built-ruby	0.237569436
built-ruby	0.238114244
built-ruby	0.235850607

-----------------------------------------------------------
so_exception

#!/usr/bin/ruby
# -*- mode: ruby -*-
# $Id: except-ruby.code,v 1.4 2004/11/13 07:41:33 bfulgham Exp $
# http://www.bagley.org/~doug/shootout/

$HI = 0
$LO = 0
NUM = 250000 # Integer(ARGV[0] || 1)


class Lo_Exception < Exception
  def initialize(num)
    @value = num
  end
end

class Hi_Exception < Exception
  def initialize(num)
    @value = num
  end
end

def some_function(num)
  begin
    hi_function(num)
  rescue
    print "We shouldn't get here, exception is: #{$!.type}\n"
  end
end

def hi_function(num)
  begin
    lo_function(num)
  rescue Hi_Exception
    $HI = $HI + 1
  end
end

def lo_function(num)
  begin
    blowup(num)
  rescue Lo_Exception
    $LO = $LO + 1
  end
end

def blowup(num)
  if num % 2 == 0
    raise Lo_Exception.new(num)
  else
    raise Hi_Exception.new(num)
  end
end


i = 1
max = NUM+1
while i < max
  i += 1
  some_function(i+1)
end

2.1.1p2	0.325388717
2.1.1p2	0.325057268
2.1.1p2	0.322413465
2.0.0p376	0.291836899
2.0.0p376	0.281782459
2.0.0p376	0.276928504
1.9.3p488	0.860840345
1.9.3p488	0.854422178
1.9.3p488	0.856075272
built-ruby	0.316294083
built-ruby	0.325901122
built-ruby	0.329178749

-----------------------------------------------------------
so_fannkuch

# The Computer Language Shootout
# http://shootout.alioth.debian.org/
# Contributed by Sokolov Yura
# Modified by Ryan Williams

def fannkuch(n)
   maxFlips, m, r, check = 0, n-1, n, 0
   count = (1..n).to_a
   perm = (1..n).to_a

   while true
      if check < 30
         puts "#{perm}"
         check += 1
      end

      while r != 1
         count[r-1] = r
         r -= 1
      end

      if perm[0] != 1 and perm[m] != n
         perml = perm.clone #.dup
         flips = 0
         while (k = perml.first ) != 1
            perml = perml.slice!(0, k).reverse + perml
            flips += 1
         end
         maxFlips = flips if flips > maxFlips
      end
      while true
         if r==n then return maxFlips end
         perm.insert r,perm.shift
         break if (count[r] -= 1) > 0
         r += 1
      end
   end
end

def puts *args
end

N = 9 # (ARGV[0] || 1).to_i
puts "Pfannkuchen(#{N}) = #{fannkuch(N)}"


2.1.1p2	1.146167175
2.1.1p2	1.131824456
2.1.1p2	1.123389168
2.0.0p376	1.190577911
2.0.0p376	1.173011017
2.0.0p376	1.222037731
1.9.3p488	1.182416891
1.9.3p488	1.18504069
1.9.3p488	1.181296606
built-ruby	1.064609471
built-ruby	1.044752546
built-ruby	1.057923539

-----------------------------------------------------------
so_fasta

# The Computer Language Shootout
# http://shootout.alioth.debian.org/
# Contributed by Sokolov Yura

$last = 42.0
def gen_random (max,im=139968,ia=3877,ic=29573)
    (max * ($last = ($last * ia + ic) % im)) / im
end

alu =
   "GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG"+
   "GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA"+
   "CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT"+
   "ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA"+
   "GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG"+
   "AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC"+
   "AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA"

iub = [
    ["a", 0.27],
    ["c", 0.12],
    ["g", 0.12],
    ["t", 0.27],

    ["B", 0.02],
    ["D", 0.02],
    ["H", 0.02],
    ["K", 0.02],
    ["M", 0.02],
    ["N", 0.02],
    ["R", 0.02],
    ["S", 0.02],
    ["V", 0.02],
    ["W", 0.02],
    ["Y", 0.02],
]
homosapiens = [
    ["a", 0.3029549426680],
    ["c", 0.1979883004921],
    ["g", 0.1975473066391],
    ["t", 0.3015094502008],
]

def make_repeat_fasta(id, desc, src, n)
    puts ">#{id} #{desc}"
    v = nil
    width = 60
    l = src.length
    s = src * ((n / l) + 1)
    s.slice!(n, l)
    puts(s.scan(/.{1,#{width}}/).join("\n"))
end

def make_random_fasta(id, desc, table, n)
    puts ">#{id} #{desc}"
    rand, v = nil,nil
    width = 60
    chunk = 1 * width
    prob = 0.0
    table.each{|v| v[1]= (prob += v[1])}
    for i in 1..(n/width)
        puts((1..width).collect{
            rand = gen_random(1.0)
            table.find{|v| v[1]>rand}[0]
        }.join)
    end
    if n%width != 0
        puts((1..(n%width)).collect{
            rand = gen_random(1.0)
            table.find{|v| v[1]>rand}[0]
        }.join)
    end
end


n = (ARGV[0] or 250_000).to_i

make_repeat_fasta('ONE', 'Homo sapiens alu', alu, n*2)
make_random_fasta('TWO', 'IUB ambiguity codes', iub, n*3)
make_random_fasta('THREE', 'Homo sapiens frequency', homosapiens, n*5)


2.1.1p2	1.942103771
2.1.1p2	1.941966313
2.1.1p2	1.934466994
2.0.0p376	1.978399561
2.0.0p376	1.97606602
2.0.0p376	1.981715455
1.9.3p488	2.210672104
1.9.3p488	2.212052808
1.9.3p488	2.214474129
built-ruby	1.964916476
built-ruby	1.959252152
built-ruby	1.972785085

-----------------------------------------------------------
so_k_nucleotide

# The Computer Language Shootout
# http://shootout.alioth.debian.org
#
# contributed by jose fco. gonzalez
# modified by Sokolov Yura

seq = String.new

def frecuency( seq,length )
    n, table = seq.length - length + 1, Hash.new(0)
    f, i = nil, nil
    (0 ... length).each do |f|
        (f ... n).step(length) do |i|
            table[seq[i,length]] += 1
        end
    end
    [n,table]

end

def sort_by_freq( seq,length )
    n,table = frecuency( seq,length )
    a, b, v = nil, nil, nil
    table.sort{|a,b| b[1] <=> a[1]}.each do |v|
        puts "%s %.3f" % [v[0].upcase,((v[1]*100).to_f/n)]
    end
    puts
end

def find_seq( seq,s )
    n,table = frecuency( seq,s.length )
    puts "#{table[s].to_s}\t#{s.upcase}"
end

input = open(File.join(File.dirname($0), 'fasta.output.100000'), 'rb')

line = input.gets while line !~ /^>THREE/
line = input.gets

while (line !~ /^>/) & line do
    seq << line.chomp
    line = input.gets
end

[1,2].each {|i| sort_by_freq( seq,i ) }

%w(ggt ggta ggtatt ggtattttaatt ggtattttaatttatagt).each{|s| find_seq( seq,s) }


2.1.1p2	1.273850339
2.1.1p2	1.265333786
2.1.1p2	1.271498009
2.0.0p376	1.379525667
2.0.0p376	1.383376617
2.0.0p376	1.397264524
1.9.3p488	1.44410359
1.9.3p488	1.437168935
1.9.3p488	1.431846302
built-ruby	1.323702097
built-ruby	1.306156321
built-ruby	1.308268933

-----------------------------------------------------------
so_lists

#from http://www.bagley.org/~doug/shootout/bench/lists/lists.ruby

NUM = 300
SIZE = 10000

def test_lists()
  # create a list of integers (Li1) from 1 to SIZE
  li1 = (1..SIZE).to_a
  # copy the list to li2 (not by individual items)
  li2 = li1.dup
  # remove each individual item from left side of li2 and
  # append to right side of li3 (preserving order)
  li3 = Array.new
  while (not li2.empty?)
    li3.push(li2.shift)
  end
  # li2 must now be empty
  # remove each individual item from right side of li3 and
  # append to right side of li2 (reversing list)
  while (not li3.empty?)
    li2.push(li3.pop)
  end
  # li3 must now be empty
  # reverse li1 in place
  li1.reverse!
  # check that first item is now SIZE
  if li1[0] != SIZE then
    p "not SIZE"
    0
  else
    # compare li1 and li2 for equality
    if li1 != li2 then
      return(0)
    else
      # return the length of the list
      li1.length
    end
  end
end

i = 0
while i<NUM
  i += 1
  result = test_lists()
end

result

2.1.1p2	0.556018272
2.1.1p2	0.543298518
2.1.1p2	0.55215019
2.0.0p376	0.545966734
2.0.0p376	0.548046187
2.0.0p376	0.542319835
1.9.3p488	0.778421954
1.9.3p488	0.775751105
1.9.3p488	0.766763313
built-ruby	0.512853457
built-ruby	0.5194303
built-ruby	0.523478016

-----------------------------------------------------------
so_mandelbrot

#  The Computer Language Benchmarks Game
#  http://shootout.alioth.debian.org/
#
#  contributed by Karl von Laudermann
#  modified by Jeremy Echols

size = 600 # ARGV[0].to_i

puts "P4\n#{size} #{size}"

ITER = 49                           # Iterations - 1 for easy for..in looping
LIMIT_SQUARED = 4.0                 # Presquared limit

byte_acc = 0
bit_num = 0

count_size = size - 1               # Precomputed size for easy for..in looping

# For..in loops are faster than .upto, .downto, .times, etc.
for y in 0..count_size
  for x in 0..count_size
    zr = 0.0
    zi = 0.0
    cr = (2.0*x/size)-1.5
    ci = (2.0*y/size)-1.0
    escape = false

    # To make use of the for..in code, we use a dummy variable,
    # like one would in C
    for dummy in 0..ITER
      tr = zr*zr - zi*zi + cr
      ti = 2*zr*zi + ci
      zr, zi = tr, ti

      if (zr*zr+zi*zi) > LIMIT_SQUARED
        escape = true
        break
      end
    end

    byte_acc = (byte_acc << 1) | (escape ? 0b0 : 0b1)
    bit_num += 1

    # Code is very similar for these cases, but using separate blocks
    # ensures we skip the shifting when it's unnecessary, which is most cases.
    if (bit_num == 8)
      print byte_acc.chr
      byte_acc = 0
      bit_num = 0
    elsif (x == count_size)
      byte_acc <<= (8 - bit_num)
      print byte_acc.chr
      byte_acc = 0
      bit_num = 0
    end
  end
end

2.1.1p2	2.060143683
2.1.1p2	2.064888202
2.1.1p2	2.089517648
2.0.0p376	2.094807149
2.0.0p376	2.122010965
2.0.0p376	2.088683758
1.9.3p488	4.27215174
1.9.3p488	4.299708441
1.9.3p488	4.294594516
built-ruby	2.045011079
built-ruby	2.042130741
built-ruby	2.045534524

-----------------------------------------------------------
so_matrix

#!/usr/bin/ruby
# -*- mode: ruby -*-
# $Id: matrix-ruby.code,v 1.4 2004/11/13 07:42:14 bfulgham Exp $
# http://www.bagley.org/~doug/shootout/

n = 60 #Integer(ARGV.shift || 1)

size = 40

def mkmatrix(rows, cols)
    count = 1
    mx = Array.new(rows)
    (0 .. (rows - 1)).each do |bi|
        row = Array.new(cols, 0)
        (0 .. (cols - 1)).each do |j|
            row[j] = count
            count += 1
        end
        mx[bi] = row
    end
    mx
end

def mmult(rows, cols, m1, m2)
    m3 = Array.new(rows)
    (0 .. (rows - 1)).each do |bi|
        row = Array.new(cols, 0)
        (0 .. (cols - 1)).each do |j|
            val = 0
            (0 .. (cols - 1)).each do |k|
                val += m1.at(bi).at(k) * m2.at(k).at(j)
            end
            row[j] = val
        end
        m3[bi] = row
    end
    m3
end

m1 = mkmatrix(size, size)
m2 = mkmatrix(size, size)
mm = Array.new
n.times do
    mm = mmult(size, size, m1, m2)
end
# puts "#{mm[0][0]} #{mm[2][3]} #{mm[3][2]} #{mm[4][4]}"



2.1.1p2	0.58008666
2.1.1p2	0.571212232
2.1.1p2	0.580901858
2.0.0p376	0.570989161
2.0.0p376	0.567225173
2.0.0p376	0.575199769
1.9.3p488	0.761310716
1.9.3p488	0.74904347
1.9.3p488	0.775379632
built-ruby	0.593705656
built-ruby	0.5731564
built-ruby	0.560781746

-----------------------------------------------------------
so_meteor_contest

#!/usr/bin/env ruby
#
# The Computer Language Shootout
#   http://shootout.alioth.debian.org
#   contributed by Kevin Barnes (Ruby novice)

# PROGRAM:  the main body is at the bottom.
#   1) read about the problem here: http://www-128.ibm.com/developerworks/java/library/j-javaopt/
#   2) see how I represent a board as a bitmask by reading the blank_board comments
#   3) read as your mental paths take you

def print *args
end

# class to represent all information about a particular rotation of a particular piece
class Rotation
  # an array (by location) containing a bit mask for how the piece maps at the given location.
  # if the rotation is invalid at that location the mask will contain false
  attr_reader :start_masks

  # maps a direction to a relative location.  these differ depending on whether it is an even or
  # odd row being mapped from
  @@rotation_even_adder = { :west => -1, :east => 1, :nw => -7, :ne => -6, :sw => 5, :se => 6 }
  @@rotation_odd_adder = { :west => -1, :east => 1, :nw => -6, :ne => -5, :sw => 6, :se => 7 }

  def initialize( directions )
    @even_offsets, @odd_offsets = normalize_offsets( get_values( directions ))

    @even_mask = mask_for_offsets( @even_offsets)
    @odd_mask = mask_for_offsets( @odd_offsets)

    @start_masks = Array.new(60)

    # create the rotational masks by placing the base mask at the location and seeing if
    # 1) it overlaps the boundaries and 2) it produces a prunable board.  if either of these
    # is true the piece cannot be placed
    0.upto(59) do | offset |
      mask = is_even(offset) ? (@even_mask << offset) : (@odd_mask << offset)
      if (blank_board & mask == 0 && !prunable(blank_board | mask, 0, true)) then
        imask = compute_required( mask, offset)
        @start_masks[offset] = [ mask, imask, imask | mask ]
      else
        @start_masks[offset] = false
      end
    end
  end

  def compute_required( mask, offset )
    board = blank_board
    0.upto(offset) { | i | board |= 1 << i }
    board |= mask
    return 0 if (!prunable(board | mask, offset))
    board = flood_fill(board,58)
    count = 0
    imask = 0
    0.upto(59) do | i |
      if (board[i] == 0) then
        imask |= (1 << i)
        count += 1
      end
    end
    (count > 0 && count < 5) ? imask : 0
  end

  def flood_fill( board, location)
    return board if (board[location] == 1)
    board |= 1 << location
    row, col = location.divmod(6)
    board = flood_fill( board, location - 1) if (col > 0)
    board = flood_fill( board, location + 1) if (col < 4)
    if (row % 2 == 0) then
      board = flood_fill( board, location - 7) if (col > 0 && row > 0)
      board = flood_fill( board, location - 6) if (row > 0)
      board = flood_fill( board, location + 6) if (row < 9)
      board = flood_fill( board, location + 5) if (col > 0 && row < 9)
    else
      board = flood_fill( board, location - 5) if (col < 4 && row > 0)
      board = flood_fill( board, location - 6) if (row > 0)
      board = flood_fill( board, location + 6) if (row < 9)
      board = flood_fill( board, location + 7) if (col < 4 && row < 9)
    end
    board
  end

  # given a location, produces a list of relative locations covered by the piece at this rotation
  def offsets( location)
    if is_even( location) then
      @even_offsets.collect { | value | value + location }
    else
      @odd_offsets.collect { | value | value + location }
    end
  end

  # returns a set of offsets relative to the top-left most piece of the rotation (by even or odd rows)
  # this is hard to explain. imagine we have this partial board:
  #   0 0 0 0 0 x        [positions 0-5]
  #    0 0 1 1 0 x       [positions 6-11]
  #   0 0 1 0 0 x        [positions 12-17]
  #    0 1 0 0 0 x       [positions 18-23]
  #   0 1 0 0 0 x        [positions 24-29]
  #    0 0 0 0 0 x       [positions 30-35]
  #       ...
  # The top-left of the piece is at position 8, the
  # board would be passed as a set of positions (values array) containing [8,9,14,19,25] not necessarily in that
  # sorted order.  Since that array starts on an odd row, the offsets for an odd row are: [0,1,6,11,17] obtained
  # by subtracting 8 from everything.  Now imagine the piece shifted up and to the right so it's on an even row:
  #   0 0 0 1 1 x        [positions 0-5]
  #    0 0 1 0 0 x       [positions 6-11]
  #   0 0 1 0 0 x        [positions 12-17]
  #    0 1 0 0 0 x       [positions 18-23]
  #   0 0 0 0 0 x        [positions 24-29]
  #    0 0 0 0 0 x       [positions 30-35]
  #       ...
  # Now the positions are [3,4,8,14,19] which after subtracting the lowest value (3) gives [0,1,5,11,16] thus, the
  # offsets for this particular piece are (in even, odd order) [0,1,5,11,16],[0,1,6,11,17] which is what
  # this function would return
  def normalize_offsets( values)
    min = values.min
    even_min = is_even(min)
    other_min = even_min ? min + 6 : min + 7
    other_values = values.collect do | value |
      if is_even(value) then
        value + 6 - other_min
      else
        value + 7 - other_min
      end
    end
    values.collect! { | value | value - min }

    if even_min then
      [values, other_values]
    else
      [other_values, values]
    end
  end

  # produce a bitmask representation of an array of offset locations
  def mask_for_offsets( offsets )
    mask = 0
    offsets.each { | value | mask = mask + ( 1 << value ) }
    mask
  end

  # finds a "safe" position that a position as described by a list of directions can be placed
  # without falling off any edge of the board.  the values returned a location to place the first piece
  # at so it will fit after making the described moves
  def start_adjust( directions )
    south = east = 0;
    directions.each do | direction |
      east += 1 if ( direction == :sw || direction == :nw || direction == :west )
      south += 1 if ( direction == :nw || direction == :ne )
    end
    south * 6 + east
  end

  # given a set of directions places the piece (as defined by a set of directions) on the board at
  # a location that will not take it off the edge
  def get_values ( directions )
    start = start_adjust(directions)
    values = [ start ]
    directions.each do | direction |
      if (start % 12 >= 6) then
        start += @@rotation_odd_adder[direction]
      else
        start += @@rotation_even_adder[direction]
      end
      values += [ start ]
    end

    # some moves take you back to an existing location, we'll strip duplicates
    values.uniq
  end
end

# describes a piece and caches information about its rotations to as to be efficient for iteration
# ATTRIBUTES:
#   rotations -- all the rotations of the piece
#   type -- a numeic "name" of the piece
#   masks -- an array by location of all legal rotational masks (a n inner array) for that location
#   placed -- the mask that this piece was last placed at (not a location, but the actual mask used)
class Piece
  attr_reader :rotations, :type, :masks
  attr_accessor :placed

  # transform hashes that change one direction into another when you either flip or rotate a set of directions
  @@flip_converter = { :west => :west, :east => :east, :nw => :sw, :ne => :se, :sw => :nw, :se => :ne }
  @@rotate_converter = { :west => :nw, :east => :se, :nw => :ne, :ne => :east, :sw => :west, :se => :sw }

  def initialize( directions, type )
    @type = type
    @rotations = Array.new();
    @map = {}

    generate_rotations( directions )
    directions.collect! { | value | @@flip_converter[value] }
    generate_rotations( directions )

    # creates the masks AND a map that returns [location, rotation] for any given mask
    # this is used when a board is found and we want to draw it, otherwise the map is unused
    @masks = Array.new();
    0.upto(59) do | i |
      even = true
      @masks[i] = @rotations.collect do | rotation |
        mask = rotation.start_masks[i]
        @map[mask[0]] = [ i, rotation ] if (mask)
        mask || nil
      end
      @masks[i].compact!
    end
  end

  # rotates a set of directions through all six angles and adds a Rotation to the list for each one
  def generate_rotations( directions )
    6.times do
      rotations.push( Rotation.new(directions))
      directions.collect! { | value | @@rotate_converter[value] }
    end
  end

  # given a board string, adds this piece to the board at whatever location/rotation
  # important: the outbound board string is 5 wide, the normal location notation is six wide (padded)
  def fill_string( board_string)
    location, rotation = @map[@placed]
    rotation.offsets(location).each do | offset |
      row, col = offset.divmod(6)
      board_string[ row*5 + col, 1 ] = @type.to_s
    end
  end
end

# a blank bit board having this form:
#
#    0 0 0 0 0 1
#     0 0 0 0 0 1
#    0 0 0 0 0 1
#     0 0 0 0 0 1
#    0 0 0 0 0 1
#     0 0 0 0 0 1
#    0 0 0 0 0 1
#     0 0 0 0 0 1
#    0 0 0 0 0 1
#     0 0 0 0 0 1
#    1 1 1 1 1 1
#
# where left lest significant bit is the top left and the most significant is the lower right
# the actual board only consists of the 0 places, the 1 places are blockers to keep things from running
# off the edges or bottom
def blank_board
  0b111111100000100000100000100000100000100000100000100000100000100000
end

def full_board
  0b111111111111111111111111111111111111111111111111111111111111111111
end

# determines if a location (bit position) is in an even row
def is_even( location)
  (location % 12) < 6
end

# support function that create three utility maps:
#  $converter -- for each row an array that maps a five bit row (via array mapping)
#                to the a a five bit representation of the bits below it
#  $bit_count -- maps a five bit row (via array mapping) to the number of 1s in the row
#  @@new_regions -- maps a five bit row (via array mapping) to an array of "region" arrays
#                   a region array has three values the first is a mask of bits in the region,
#                   the second is the count of those bits and the third is identical to the first
#                   examples:
#                           0b10010 => [ 0b01100, 2, 0b01100 ], [ 0b00001, 1, 0b00001]
#                           0b01010 => [ 0b10000, 1, 0b10000 ], [ 0b00100, 1, 0b00100 ], [ 0b00001, 1, 0b00001]
#                           0b10001 => [ 0b01110, 3, 0b01110 ]
def create_collector_support
  odd_map = [0b11, 0b110, 0b1100, 0b11000, 0b10000]
  even_map = [0b1, 0b11, 0b110, 0b1100, 0b11000]

  all_odds = Array.new(0b100000)
  all_evens = Array.new(0b100000)
  bit_counts = Array.new(0b100000)
  new_regions = Array.new(0b100000)
  0.upto(0b11111) do | i |
    bit_count = odd = even = 0
    0.upto(4) do | bit |
      if (i[bit] == 1) then
        bit_count += 1
        odd |= odd_map[bit]
        even |= even_map[bit]
      end
    end
    all_odds[i] = odd
    all_evens[i] = even
    bit_counts[i] = bit_count
    new_regions[i] = create_regions( i)
  end

  $converter = []
  10.times { | row | $converter.push((row % 2 == 0) ? all_evens : all_odds) }
  $bit_counts = bit_counts
  $regions = new_regions.collect { | set | set.collect { | value | [ value, bit_counts[value], value] } }
end

# determines if a board is punable, meaning that there is no possibility that it
# can be filled up with pieces.  A board is prunable if there is a grouping of unfilled spaces
# that are not a multiple of five.  The following board is an example of a prunable board:
#    0 0 1 0 0
#     0 1 0 0 0
#    1 1 0 0 0
#     0 1 0 0 0
#    0 0 0 0 0
#       ...
#
# This board is prunable because the top left corner is only 3 bits in area, no piece will ever fit it
# parameters:
#   board -- an initial bit board (6 bit padded rows, see blank_board for format)
#   location -- starting location, everything above and to the left is already full
#   slotting -- set to true only when testing initial pieces, when filling normally
#               additional assumptions are possible
#
# Algorithm:
#    The algorithm starts at the top row (as determined by location) and iterates a row at a time
#    maintainng counts of active open areas (kept in the collector array) each collector contains
#    three values at the start of an iteration:
#          0: mask of bits that would be adjacent to the collector in this row
#          1: the number of bits collected so far
#          2: a scratch space starting as zero, but used during the computation to represent
#             the empty bits in the new row that are adjacent (position 0)
#  The exact procedure is described in-code
def prunable( board, location, slotting = false)
  collectors = []
  # loop across the rows
  (location / 6).to_i.upto(9) do | row_on |
    # obtain a set of regions representing the bits of the current row.
    regions = $regions[(board >> (row_on * 6)) & 0b11111]
    converter = $converter[row_on]

    # track the number of collectors at the start of the cycle so that
    # we don't compute against newly created collectors, only existing collectors
    initial_collector_count = collectors.length

    # loop against the regions.  For each region of the row
    # we will see if it connects to one or more existing collectors.
    # if it connects to 1 collector, the bits from the region are added to the
    # bits of the collector and the mask is placed in collector[2]
    # If the region overlaps more than one collector then all the collectors
    # it overlaps with are merged into the first one (the others are set to nil in the array)
    # if NO collectors are found then the region is copied as a new collector
    regions.each do | region |
      collector_found = nil
      region_mask = region[2]
      initial_collector_count.times do | collector_num |
        collector = collectors[collector_num]
        if (collector) then
          collector_mask = collector[0]
          if (collector_mask & region_mask != 0) then
            if (collector_found) then
              collector_found[0] |= collector_mask
              collector_found[1] += collector[1]
              collector_found[2] |= collector[2]
              collectors[collector_num] = nil
            else
              collector_found = collector
              collector[1] += region[1]
              collector[2] |= region_mask
            end
          end
        end
      end
      if (collector_found == nil) then
        collectors.push(Array.new(region))
      end
    end

    # check the existing collectors, if any collector overlapped no bits in the region its [2] value will
    # be zero.  The size of any such reaason is tested if it is not a multiple of five true is returned since
    # the board is prunable.  if it is a multiple of five it is removed.
    # Collector that are still active have a new adjacent value [0] set based n the matched bits
    # and have [2] cleared out for the next cycle.
    collectors.length.times do | collector_num |
      collector = collectors[collector_num]
      if (collector) then
        if (collector[2] == 0) then
          return true if (collector[1] % 5 != 0)
          collectors[collector_num] = nil
        else
          # if a collector matches all bits in the row then we can return unprunable early for the
          # following reasons:
          #    1) there can be no more unavailable bits bince we fill from the top left downward
          #    2) all previous regions have been closed or joined so only this region can fail
          #    3) this region must be good since there can never be only 1 region that is nuot
          #       a multiple of five
          # this rule only applies when filling normally, so we ignore the rule if we are "slotting"
          # in pieces to see what configurations work for them (the only other time this algorithm is used).
          return false if (collector[2] == 0b11111 && !slotting)
          collector[0] = converter[collector[2]]
          collector[2] = 0
        end
      end
    end

    # get rid of all the empty converters for the next round
    collectors.compact!
  end
  return false if (collectors.length <= 1) # 1 collector or less and the region is fine
  collectors.any? { | collector | (collector[1] % 5) != 0 } # more than 1 and we test them all for bad size
end

# creates a region given a row mask.  see prunable for what a "region" is
def create_regions( value )
  regions = []
  cur_region = 0
  5.times do | bit |
    if (value[bit] == 0) then
      cur_region |= 1 << bit
    else
      if (cur_region != 0 ) then
        regions.push( cur_region)
        cur_region = 0;
      end
    end
  end
  regions.push(cur_region) if (cur_region != 0)
  regions
end

# find up to the counted number of solutions (or all solutions) and prints the final result
def find_all
  find_top( 1)
  find_top( 0)
  print_results
end

# show the board
def print_results
  print "#{@boards_found} solutions found\n\n"
  print_full_board( @min_board)
  print "\n"
  print_full_board( @max_board)
  print "\n"
end

# finds solutions.  This special version of the main function is only used for the top level
# the reason for it is basically to force a particular ordering on how the rotations are tested for
# the first piece.  It is called twice, first looking for placements of the odd rotations and then
# looking for placements of the even locations.
#
# WHY?
#   Since any found solution has an inverse we want to maximize finding solutions that are not already found
#   as an inverse.  The inverse will ALWAYS be 3 one of the piece configurations that is exactly 3 rotations away
#   (an odd number).  Checking even vs odd then produces a higher probability of finding more pieces earlier
#   in the cycle.  We still need to keep checking all the permutations, but our probability of finding one will
#   diminsh over time.  Since we are TOLD how many to search for this lets us exit before checking all pieces
#   this bennifit is very great when seeking small numbers of solutions and is 0 when looking for more than the
#   maximum number
def find_top( rotation_skip)
  board = blank_board
  (@pieces.length-1).times do
    piece = @pieces.shift
    piece.masks[0].each do | mask, imask, cmask |
      if ((rotation_skip += 1) % 2 == 0) then
        piece.placed = mask
        find( 1, 1, board | mask)
      end
    end
    @pieces.push(piece)
  end
  piece = @pieces.shift
  @pieces.push(piece)
end

# the normail find routine, iterates through the available pieces, checks all rotations at the current location
# and adds any boards found.  depth is acheived via recursion.  the overall approach is described
# here: http://www-128.ibm.com/developerworks/java/library/j-javaopt/
# parameters:
#  start_location -- where to start looking for place for the next piece at
#  placed -- number of pieces placed
#  board -- current state of the board
#
# see in-code comments
def find( start_location, placed, board)
  # find the next location to place a piece by looking for an empty bit
  while board[start_location] == 1
    start_location += 1
  end

  @pieces.length.times do
    piece = @pieces.shift
    piece.masks[start_location].each do | mask, imask, cmask |
      if ( board & cmask == imask) then
        piece.placed = mask
        if (placed == 9) then
          add_board
        else
          find( start_location + 1, placed + 1, board | mask)
        end
      end
    end
    @pieces.push(piece)
  end
end

# print the board
def print_full_board( board_string)
  10.times do | row |
    print " " if (row % 2 == 1)
    5.times do | col |
      print "#{board_string[row*5 + col,1]} "
    end
    print "\n"
  end
end

# when a board is found we "draw it" into a string and then flip that string, adding both to
# the list (hash) of solutions if they are unique.
def add_board
  board_string = "99999999999999999999999999999999999999999999999999"
  @all_pieces.each {  | piece | piece.fill_string( board_string ) }
  save( board_string)
  save( board_string.reverse)
end

# adds a board string to the list (if new) and updates the current best/worst board
def save( board_string)
  if (@all_boards[board_string] == nil) then
    @min_board = board_string if (board_string < @min_board)
    @max_board = board_string if (board_string > @max_board)
    @all_boards.store(board_string,true)
    @boards_found += 1

    # the exit motif is a time saver.  Ideally the function should return, but those tests
    # take noticeable time (performance).
    if (@boards_found == @stop_count) then
      print_results
      exit(0)
    end
  end
end


##
## MAIN BODY :)
##
create_collector_support
@pieces = [
  Piece.new( [ :nw, :ne, :east, :east ], 2),
  Piece.new( [ :ne, :se, :east, :ne ], 7),
  Piece.new( [ :ne, :east, :ne, :nw ], 1),
  Piece.new( [ :east, :sw, :sw, :se ], 6),
  Piece.new( [ :east, :ne, :se, :ne ], 5),
  Piece.new( [ :east, :east, :east, :se ], 0),
  Piece.new( [ :ne, :nw, :se, :east, :se ], 4),
  Piece.new( [ :se, :se, :se, :west ], 9),
  Piece.new( [ :se, :se, :east, :se ], 8),
  Piece.new( [ :east, :east, :sw, :se ], 3)
  ];

@all_pieces = Array.new( @pieces)

@min_board = "99999999999999999999999999999999999999999999999999"
@max_board = "00000000000000000000000000000000000000000000000000"
@stop_count = ARGV[0].to_i || 2089
@all_boards = {}
@boards_found = 0

find_all ######## DO IT!!!


2.1.1p2	3.077131799
2.1.1p2	2.955562836
2.1.1p2	3.046814941
2.0.0p376	3.476820479
2.0.0p376	3.476541584
2.0.0p376	3.48787717
1.9.3p488	4.129935474
1.9.3p488	4.129596154
1.9.3p488	4.140483484
built-ruby	3.169448614
built-ruby	3.131979457
built-ruby	3.138839768

-----------------------------------------------------------
so_nbody

# The Computer Language Shootout
# http://shootout.alioth.debian.org
#
# Optimized for Ruby by Jesse Millikan
# From version ported by Michael Neumann from the C gcc version,
# which was written by Christoph Bauer.

SOLAR_MASS = 4 * Math::PI**2
DAYS_PER_YEAR = 365.24

def _puts *args
end

class Planet
 attr_accessor :x, :y, :z, :vx, :vy, :vz, :mass

 def initialize(x, y, z, vx, vy, vz, mass)
  @x, @y, @z = x, y, z
  @vx, @vy, @vz = vx * DAYS_PER_YEAR, vy * DAYS_PER_YEAR, vz * DAYS_PER_YEAR
  @mass = mass * SOLAR_MASS
 end

 def move_from_i(bodies, nbodies, dt, i)
  while i < nbodies
   b2 = bodies[i]
   dx = @x - b2.x
   dy = @y - b2.y
   dz = @z - b2.z

   distance = Math.sqrt(dx * dx + dy * dy + dz * dz)
   mag = dt / (distance * distance * distance)
   b_mass_mag, b2_mass_mag = @mass * mag, b2.mass * mag

   @vx -= dx * b2_mass_mag
   @vy -= dy * b2_mass_mag
   @vz -= dz * b2_mass_mag
   b2.vx += dx * b_mass_mag
   b2.vy += dy * b_mass_mag
   b2.vz += dz * b_mass_mag
   i += 1
  end

  @x += dt * @vx
  @y += dt * @vy
  @z += dt * @vz
 end
end

def energy(bodies)
  e = 0.0
  nbodies = bodies.size

  for i in 0 ... nbodies
    b = bodies[i]
    e += 0.5 * b.mass * (b.vx * b.vx + b.vy * b.vy + b.vz * b.vz)
    for j in (i + 1) ... nbodies
      b2 = bodies[j]
      dx = b.x - b2.x
      dy = b.y - b2.y
      dz = b.z - b2.z
      distance = Math.sqrt(dx * dx + dy * dy + dz * dz)
      e -= (b.mass * b2.mass) / distance
    end
  end
  e
end

def offset_momentum(bodies)
  px, py, pz = 0.0, 0.0, 0.0

  for b in bodies
    m = b.mass
    px += b.vx * m
    py += b.vy * m
    pz += b.vz * m
  end

  b = bodies[0]
  b.vx = - px / SOLAR_MASS
  b.vy = - py / SOLAR_MASS
  b.vz = - pz / SOLAR_MASS
end

BODIES = [
  # sun
  Planet.new(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0),

  # jupiter
  Planet.new(
    4.84143144246472090e+00,
    -1.16032004402742839e+00,
    -1.03622044471123109e-01,
    1.66007664274403694e-03,
    7.69901118419740425e-03,
    -6.90460016972063023e-05,
    9.54791938424326609e-04),

  # saturn
  Planet.new(
    8.34336671824457987e+00,
    4.12479856412430479e+00,
    -4.03523417114321381e-01,
    -2.76742510726862411e-03,
    4.99852801234917238e-03,
    2.30417297573763929e-05,
    2.85885980666130812e-04),

  # uranus
  Planet.new(
    1.28943695621391310e+01,
    -1.51111514016986312e+01,
    -2.23307578892655734e-01,
    2.96460137564761618e-03,
    2.37847173959480950e-03,
    -2.96589568540237556e-05,
    4.36624404335156298e-05),

  # neptune
  Planet.new(
    1.53796971148509165e+01,
    -2.59193146099879641e+01,
    1.79258772950371181e-01,
    2.68067772490389322e-03,
    1.62824170038242295e-03,
    -9.51592254519715870e-05,
    5.15138902046611451e-05)
]

init = 200_000 # ARGV[0]
n = Integer(init)

offset_momentum(BODIES)

puts "%.9f" % energy(BODIES)

nbodies = BODIES.size
dt = 0.01

n.times do
  i = 0
  while i < nbodies
    b = BODIES[i]
    b.move_from_i(BODIES, nbodies, dt, i + 1)
    i += 1
  end
end

puts "%.9f" % energy(BODIES)

2.1.1p2	1.337051469
2.1.1p2	1.318095332
2.1.1p2	1.327789653
2.0.0p376	1.364106408
2.0.0p376	1.363850084
2.0.0p376	1.362785593
1.9.3p488	3.280226033
1.9.3p488	3.181781751
1.9.3p488	3.173823337
built-ruby	1.344392865
built-ruby	1.366482906
built-ruby	1.352117001

-----------------------------------------------------------
so_nested_loop

#!/usr/bin/ruby
# -*- mode: ruby -*-
# $Id: nestedloop-ruby.code,v 1.4 2004/11/13 07:42:22 bfulgham Exp $
# http://www.bagley.org/~doug/shootout/
# from Avi Bryant

n = 16 # Integer(ARGV.shift || 1)
x = 0
n.times do
    n.times do
        n.times do
            n.times do
                n.times do
                    n.times do
                        x += 1
                    end
                end
            end
        end
    end
end
# puts x



2.1.1p2	1.043109006
2.1.1p2	1.04875546
2.1.1p2	1.042104108
2.0.0p376	1.050889156
2.0.0p376	1.054536712
2.0.0p376	1.065242671
1.9.3p488	1.141826801
1.9.3p488	1.103084116
1.9.3p488	1.100470206
built-ruby	1.119196947
built-ruby	1.088138852
built-ruby	1.089133556

-----------------------------------------------------------
so_nsieve

# The Computer Language Shootout
# http://shootout.alioth.debian.org/
#
# contributed by Glenn Parker, March 2005
# modified by Evan Phoenix, Sept 2006

def sieve(m)
  flags = Flags.dup[0,m]
  count = 0
  pmax = m - 1
  p = 2
  while p <= pmax
    unless flags[p].zero?
      count += 1
      mult = p
      while mult <= pmax
        flags[mult] = 0
        mult += p
      end
    end
    p += 1
  end
  count
end

n = 9 # (ARGV[0] || 2).to_i
Flags = ("\x1" * ( 2 ** n * 10_000)).unpack("c*")

n.downto(n-2) do |exponent|
  break if exponent < 0
  m = (1 << exponent) * 10_000
  # m = (2 ** exponent) * 10_000
  count = sieve(m)
  printf "Primes up to %8d %8d\n", m, count
end

2.1.1p2	1.862842711
2.1.1p2	1.856037969
2.1.1p2	1.874550231
2.0.0p376	2.072198453
2.0.0p376	2.083547824
2.0.0p376	2.118317449
1.9.3p488	2.5084232
1.9.3p488	2.517854763
1.9.3p488	2.511183343
built-ruby	1.809183842
built-ruby	1.808480077
built-ruby	1.806064479

-----------------------------------------------------------
so_nsieve_bits

#!/usr/bin/ruby
#coding: us-ascii
#
# The Great Computer Language Shootout
# http://shootout.alioth.debian.org/
#
# nsieve-bits in Ruby
# Contributed by Glenn Parker, March 2005

CharExponent = 3
BitsPerChar = 1 << CharExponent
LowMask = BitsPerChar - 1

def sieve(m)
  items = "\xFF" * ((m / BitsPerChar) + 1)
  masks = ""
  BitsPerChar.times do |b|
    masks << (1 << b).chr
  end

  count = 0
  pmax = m - 1
  2.step(pmax, 1) do |p|
    if items[p >> CharExponent][p & LowMask] == 1
      count += 1
      p.step(pmax, p) do |mult|
	a = mult >> CharExponent
	b = mult & LowMask
	items[a] -= masks[b] if items[a][b] != 0
      end
    end
  end
  count
end

n = 9 # (ARGV[0] || 2).to_i
n.step(n - 2, -1) do |exponent|
  break if exponent < 0
  m = 2 ** exponent * 10_000
  count = sieve(m)
  printf "Primes up to %8d %8d\n", m, count
end


2.1.1p2	2.315777357
2.1.1p2	2.265442666
2.1.1p2	2.289582117
2.0.0p376	2.245906781
2.0.0p376	2.256440352
2.0.0p376	2.277092141
1.9.3p488	2.519811231
1.9.3p488	2.51784622
1.9.3p488	2.54408915
built-ruby	2.272965052
built-ruby	2.285362301
built-ruby	2.263050009

-----------------------------------------------------------
so_object

#!/usr/bin/ruby
# -*- mode: ruby -*-
# $Id: objinst-ruby.code,v 1.4 2004/11/13 07:42:25 bfulgham Exp $
# http://www.bagley.org/~doug/shootout/
# with help from Aristarkh Zagorodnikov

class Toggle
    def initialize(start_state)
        @bool = start_state
    end

    def value
        @bool
    end

    def activate
        @bool = !@bool
        self
    end
end

class NthToggle < Toggle
    def initialize(start_state, max_counter)
        super start_state
        @count_max = max_counter
        @counter = 0
    end

    def activate
        @counter += 1
        if @counter >= @count_max
            @bool = !@bool
            @counter = 0
        end
        self
    end
end

n = 1500000 # (ARGV.shift || 1).to_i

toggle = Toggle.new 1
5.times do
    toggle.activate.value ? 'true' : 'false'
end
n.times do
    toggle = Toggle.new 1
end

ntoggle = NthToggle.new 1, 3
8.times do
    ntoggle.activate.value ? 'true' : 'false'
end
n.times do
    ntoggle = NthToggle.new 1, 3
end


2.1.1p2	0.701306889
2.1.1p2	0.695321153
2.1.1p2	0.69648523
2.0.0p376	0.766356714
2.0.0p376	0.76327134
2.0.0p376	0.761880767
1.9.3p488	0.828286061
1.9.3p488	0.842289449
1.9.3p488	0.830387654
built-ruby	0.717265502
built-ruby	0.717468459
built-ruby	0.714658146

-----------------------------------------------------------
so_partial_sums

n = 2_500_000 # (ARGV.shift || 1).to_i

alt = 1.0 ; s0 = s1 = s2 = s3 = s4 = s5 = s6 = s7 = s8 = 0.0

1.upto(n) do |d|
  d = d.to_f ; d2 = d * d ; d3 = d2 * d ; ds = Math.sin(d) ; dc = Math.cos(d)

  s0 += (2.0 / 3.0) ** (d - 1.0)
  s1 += 1.0 / Math.sqrt(d)
  s2 += 1.0 / (d * (d + 1.0))
  s3 += 1.0 / (d3 * ds * ds)
  s4 += 1.0 / (d3 * dc * dc)
  s5 += 1.0 / d
  s6 += 1.0 / d2
  s7 += alt / d
  s8 += alt / (2.0 * d - 1.0)

  alt = -alt
end

if false
  printf("%.9f\t(2/3)^k\n", s0)
  printf("%.9f\tk^-0.5\n", s1)
  printf("%.9f\t1/k(k+1)\n", s2)
  printf("%.9f\tFlint Hills\n", s3)
  printf("%.9f\tCookson Hills\n", s4)
  printf("%.9f\tHarmonic\n", s5)
  printf("%.9f\tRiemann Zeta\n", s6)
  printf("%.9f\tAlternating Harmonic\n", s7)
  printf("%.9f\tGregory\n", s8)
end

2.1.1p2	1.828271948
2.1.1p2	1.831203115
2.1.1p2	1.833619587
2.0.0p376	1.851996506
2.0.0p376	1.890893315
2.0.0p376	1.899806002
1.9.3p488	4.056615998
1.9.3p488	4.078569385
1.9.3p488	4.111150782
built-ruby	1.856624521
built-ruby	1.848451891
built-ruby	1.845182478

-----------------------------------------------------------
so_pidigits

# The Great Computer Language Shootout
# http://shootout.alioth.debian.org/
#
# contributed by Gabriele Renzi

class PiDigitSpigot

    def initialize()
        @z = Transformation.new 1,0,0,1
        @x = Transformation.new 0,0,0,0
        @inverse = Transformation.new 0,0,0,0
    end

    def next!
        @y = @z.extract(3)
        if safe? @y
            @z = produce(@y)
            @y
        else
            @z = consume @x.next!()
            next!()
        end
    end

    def safe?(digit)
        digit == @z.extract(4)
    end

    def produce(i)
        @inverse.qrst(10,-10*i,0,1).compose(@z)
    end

    def consume(a)
        @z.compose(a)
    end
end


class Transformation
    attr_reader :q, :r, :s, :t
    def initialize (q, r, s, t)
        @q,@r,@s,@t,@k = q,r,s,t,0
    end

    def next!()
        @q = @k = @k + 1
        @r = 4 * @k + 2
        @s = 0
        @t = 2 * @k + 1
        self
    end

    def extract(j)
        (@q * j + @r) / (@s * j + @t)
    end

    def compose(a)
        self.class.new( @q * a.q,
                        @q * a.r + r * a.t,
                        @s * a.q + t * a.s,
                        @s * a.r + t * a.t
                    )
    end

    def qrst *args
        initialize *args
        self
    end


end


WIDTH = 10
n = 2_500 # Integer(ARGV[0])
j = 0

digits = PiDigitSpigot.new

while n > 0
    if n >= WIDTH
        WIDTH.times {print digits.next!}
        j += WIDTH
    else
        n.times {print digits.next!}
        (WIDTH-n).times {print " "}
        j += n
    end
    puts "\t:"+j.to_s
    n -= WIDTH
end


2.1.1p2	0.555615786
2.1.1p2	0.546697736
2.1.1p2	0.547382519
2.0.0p376	0.709998677
2.0.0p376	0.714492918
2.0.0p376	0.712472939
1.9.3p488	0.612329516
1.9.3p488	0.612637053
1.9.3p488	0.613134267
built-ruby	0.493146282
built-ruby	0.493823501
built-ruby	0.493427098

-----------------------------------------------------------
so_random

# from http://www.bagley.org/~doug/shootout/bench/random/random.ruby

IM = 139968.0
IA = 3877.0
IC = 29573.0

$last = 42.0

def gen_random(max)
  (max * ($last = ($last * IA + IC) % IM)) / IM
end

N = 3_000_000

i = 0
while i<N
  i +=1
  gen_random(100.0)
end
# "%.9f" % gen_random(100.0)

2.1.1p2	0.520703109
2.1.1p2	0.510913006
2.1.1p2	0.510056372
2.0.0p376	0.526987447
2.0.0p376	0.52327142
2.0.0p376	0.523104733
1.9.3p488	0.887510263
1.9.3p488	0.913544793
1.9.3p488	0.882488864
built-ruby	0.517508249
built-ruby	0.523920966
built-ruby	0.515691037

-----------------------------------------------------------
so_reverse_complement

#!/usr/bin/ruby
# The Great Computer Language Shootout
# http://shootout.alioth.debian.org/
#
# Contributed by Peter Bjarke Olsen
# Modified by Doug King

seq=Array.new

def revcomp(seq)
  seq.reverse!.tr!('wsatugcyrkmbdhvnATUGCYRKMBDHVN','WSTAACGRYMKVHDBNTAACGRYMKVHDBN')
  stringlen=seq.length
  0.step(stringlen-1,60) {|x| print seq.slice(x,60) , "\n"}
end

input = open(File.join(File.dirname($0), 'fasta.output.2500000'), 'rb')

while input.gets
  if $_ =~ />/
    if seq.length != 0
      revcomp(seq.join)
      seq=Array.new
    end
    puts $_
  else
    $_.sub(/\n/,'')
    seq.push $_
  end
end
revcomp(seq.join)

2.1.1p2	1.305916953
2.1.1p2	2.265054004
2.1.1p2	1.822650533
2.0.0p376	1.976385712
2.0.0p376	1.992948438
2.0.0p376	2.038749118
1.9.3p488	1.822591654
1.9.3p488	1.853377638
1.9.3p488	1.830097186
built-ruby	1.910687143
built-ruby	1.901452372
built-ruby	1.891457887

-----------------------------------------------------------
so_sieve

# from http://www.bagley.org/~doug/shootout/bench/sieve/sieve.ruby
num = 500
count = i = j = 0
flags0 = Array.new(8192,1)
k = 0
while k < num
  k += 1
  count = 0
  flags = flags0.dup
  i = 2
  while i<8192
    i += 1
    if flags[i]
      # remove all multiples of prime: i
      j = i*i
      while j < 8192
        j += i
        flags[j] = nil
      end
      count += 1
    end
  end
end
count

2.1.1p2	0.617184921
2.1.1p2	0.622036936
2.1.1p2	0.618206849
2.0.0p376	0.715317233
2.0.0p376	0.709361485
2.0.0p376	0.714483321
1.9.3p488	0.840763793
1.9.3p488	0.834929173
1.9.3p488	0.834748767
built-ruby	0.597862855
built-ruby	0.59153191
built-ruby	0.588468323

-----------------------------------------------------------
so_spectralnorm

# The Computer Language Shootout
# http://shootout.alioth.debian.org/
# Contributed by Sokolov Yura

def eval_A(i,j)
	return 1.0/((i+j)*(i+j+1)/2+i+1)
end

def eval_A_times_u(u)
        v, i = nil, nil
	(0..u.length-1).collect { |i|
                v = 0
		for j in 0..u.length-1
			v += eval_A(i,j)*u[j]
                end
                v
        }
end

def eval_At_times_u(u)
	v, i = nil, nil
	(0..u.length-1).collect{|i|
                v = 0
		for j in 0..u.length-1
			v += eval_A(j,i)*u[j]
                end
                v
        }
end

def eval_AtA_times_u(u)
	return eval_At_times_u(eval_A_times_u(u))
end

n = 500 # ARGV[0].to_i

u=[1]*n
for i in 1..10
        v=eval_AtA_times_u(u)
        u=eval_AtA_times_u(v)
end
vBv=0
vv=0
for i in 0..n-1
        vBv += u[i]*v[i]
        vv += v[i]*v[i]
end

str = "%0.9f" % (Math.sqrt(vBv/vv)), "\n"
# print str

2.1.1p2	1.850613653
2.1.1p2	1.843206465
2.1.1p2	1.851691918
2.0.0p376	1.90098281
2.0.0p376	1.886036809
2.0.0p376	1.940763777
1.9.3p488	3.079652843
1.9.3p488	3.081073181
1.9.3p488	3.088303859
built-ruby	1.982550399
built-ruby	1.982257948
built-ruby	2.016638799

-----------------------------------------------------------
vm1_attr_ivar

class C
  attr_reader :a, :b
  def initialize
    @a = nil
    @b = nil
  end
end
obj = C.new
i = 0
while i<30_000_000 # while loop 1
  i += 1
  j = obj.a
  k = obj.b
end

2.1.1p2	1.409501514
2.1.1p2	1.412510847
2.1.1p2	1.413082087
2.0.0p376	1.448197691
2.0.0p376	1.453029974
2.0.0p376	1.448789519
1.9.3p488	2.322807771
1.9.3p488	2.333871521
1.9.3p488	2.321210116
built-ruby	1.435117318
built-ruby	1.426191909
built-ruby	1.430098101

-----------------------------------------------------------
vm1_attr_ivar_set

class C
  attr_accessor :a, :b
  def initialize
    @a = nil
    @b = nil
  end
end
obj = C.new
i = 0
while i<30_000_000 # while loop 1
  i += 1
  obj.a = 1
  obj.b = 2
end

2.1.1p2	1.544271134
2.1.1p2	1.560318882
2.1.1p2	1.539478458
2.0.0p376	1.705332635
2.0.0p376	1.702858489
2.0.0p376	1.70591799
1.9.3p488	2.659590761
1.9.3p488	2.657678174
1.9.3p488	2.66401227
built-ruby	1.580836895
built-ruby	1.570063354
built-ruby	1.572116217

-----------------------------------------------------------
vm1_block

def m
  yield
end

i = 0
while i<30_000_000 # while loop 1
  i += 1
  m{
  }
end

2.1.1p2	2.027474208
2.1.1p2	2.015619852
2.1.1p2	2.031384068
2.0.0p376	2.123423401
2.0.0p376	2.061819708
2.0.0p376	2.063553501
1.9.3p488	2.295317418
1.9.3p488	2.24013797
1.9.3p488	2.23835669
built-ruby	2.215372397
built-ruby	2.250257682
built-ruby	2.214198491

-----------------------------------------------------------
vm1_const

Const = 1

i = 0
while i<30_000_000 # while loop 1
  i += 1
  j = Const
  k = Const
end

2.1.1p2	0.881789307
2.1.1p2	0.882730331
2.1.1p2	0.881487637
2.0.0p376	0.920451018
2.0.0p376	0.920934651
2.0.0p376	0.918383514
1.9.3p488	0.920411176
1.9.3p488	0.924041291
1.9.3p488	0.919675464
built-ruby	0.880008471
built-ruby	0.88010216
built-ruby	0.880544008

-----------------------------------------------------------
vm1_ensure

i = 0
while i<30_000_000 # benchmark loop 1
  i += 1
  begin
    begin
    ensure
    end
  ensure
  end
end


2.1.1p2	0.656150322
2.1.1p2	0.655332181
2.1.1p2	0.655937213
2.0.0p376	0.667367947
2.0.0p376	0.670309181
2.0.0p376	0.666726669
1.9.3p488	0.666402253
1.9.3p488	0.669295379
1.9.3p488	0.666013928
built-ruby	0.642919439
built-ruby	0.659550725
built-ruby	0.653741877

-----------------------------------------------------------
vm1_float_simple

i = 0.0; f = 0.0
while i<30_000_000
  i += 1
  f += 0.1; f -= 0.1
  f += 0.1; f -= 0.1
  f += 0.1; f -= 0.1
end

2.1.1p2	4.827171868
2.1.1p2	4.802183205
2.1.1p2	4.724098101
2.0.0p376	4.574588228
2.0.0p376	4.55461964
2.0.0p376	4.509852549
1.9.3p488	9.30687233
1.9.3p488	9.28117027
1.9.3p488	9.255304719
built-ruby	4.669843545
built-ruby	4.609064616
built-ruby	4.643201517

-----------------------------------------------------------
vm1_gc_short_lived

i = 0
while i<30_000_000 # while loop 1
  a = '' # short-lived String
  b = ''
  c = ''
  d = ''
  e = ''
  f = ''
  i+=1
end

2.1.1p2	10.585113718
2.1.1p2	10.964990482
2.1.1p2	10.827571894
2.0.0p376	11.245535617
2.0.0p376	11.257200715
2.0.0p376	11.30997148
1.9.3p488	10.393903832
1.9.3p488	10.366449899
1.9.3p488	10.372020497
built-ruby	10.892790128
built-ruby	10.902945412
built-ruby	10.93803811

-----------------------------------------------------------
vm1_gc_short_with_complex_long

def nested_hash h, n
  if n == 0
    ''
  else
    10.times{
      h[Object.new] = nested_hash(h, n-1)
    }
  end
end

long_lived = Hash.new
nested_hash long_lived, 6

GC.start
GC.start

i = 0
while i<30_000_000 # while loop 1
  a = '' # short-lived String
  b = ''
  c = ''
  d = ''
  e = ''
  f = ''
  i+=1
end


2.1.1p2	11.85656024
2.1.1p2	12.559234527
2.1.1p2	12.471197195
2.0.0p376	15.682867214
2.0.0p376	15.487801102
2.0.0p376	15.411736612
1.9.3p488	14.9093197
1.9.3p488	14.865838933
1.9.3p488	15.266519983
built-ruby	12.969565326
built-ruby	12.961450346
built-ruby	13.006964712

-----------------------------------------------------------
vm1_gc_short_with_long

long_lived = Array.new(1_000_000){|i| "#{i}"}
GC.start
GC.start
i = 0
while i<30_000_000 # while loop 1
  a = '' # short-lived String
  b = ''
  c = ''
  d = ''
  e = ''
  f = ''
  i+=1
end

2.1.1p2	11.565594877
2.1.1p2	11.810769512
2.1.1p2	11.782698653
2.0.0p376	11.506701494
2.0.0p376	11.51405556
2.0.0p376	11.833478699
1.9.3p488	13.768885383
1.9.3p488	13.556617292
1.9.3p488	13.742729596
built-ruby	11.474787459
built-ruby	11.515869424
built-ruby	11.472725112

-----------------------------------------------------------
vm1_gc_short_with_symbol

# make many symbols
50_000.times{|i| sym = "sym#{i}".to_sym}
GC.start
GC.start

i = 0
while i<30_000_000 # while loop 1
  a = '' # short-lived String
  b = ''
  c = ''
  d = ''
  e = ''
  f = ''
  i+=1
end

2.1.1p2	10.302245109
2.1.1p2	10.843522858
2.1.1p2	10.807801746
2.0.0p376	12.757823554
2.0.0p376	12.778705022
2.0.0p376	12.721510023
1.9.3p488	16.379989977
1.9.3p488	16.040176199
1.9.3p488	16.438849341
built-ruby	11.559599339
built-ruby	11.479860124
built-ruby	11.332841803

-----------------------------------------------------------
vm1_gc_wb_ary

long_lived = []
GC.start
GC.start

i = 0
short_lived = ''
while i<30_000_000 # while loop 1
  long_lived[0] = short_lived # write barrier
  i+=1
end

2.1.1p2	1.284043953
2.1.1p2	1.272226923
2.1.1p2	1.273858504
2.0.0p376	1.61952637
2.0.0p376	1.62739005
2.0.0p376	1.620812514
1.9.3p488	2.028061662
1.9.3p488	2.038311126
1.9.3p488	2.034058548
built-ruby	1.274262665
built-ruby	1.266927678
built-ruby	1.264216429

-----------------------------------------------------------
vm1_gc_wb_obj

class C
  attr_accessor :foo
end
long_lived = C.new
GC.start
GC.start

i = 0
short_lived = ''
while i<30_000_000 # while loop 1
  long_lived.foo = short_lived # write barrier
  i+=1
end

2.1.1p2	1.242712392
2.1.1p2	1.237639985
2.1.1p2	1.239585049
2.0.0p376	1.157790336
2.0.0p376	1.182896289
2.0.0p376	1.175596527
1.9.3p488	1.650151729
1.9.3p488	1.701067733
1.9.3p488	1.723459
built-ruby	1.22605842
built-ruby	1.223808326
built-ruby	1.234651391

-----------------------------------------------------------
vm1_ivar

@a = 1

i = 0
while i<30_000_000 # while loop 1
  i += 1
  j = @a
  k = @a
end

2.1.1p2	1.051577045
2.1.1p2	1.024985434
2.1.1p2	1.026588399
2.0.0p376	1.084304551
2.0.0p376	1.089094486
2.0.0p376	1.084993288
1.9.3p488	0.969944283
1.9.3p488	0.972278355
1.9.3p488	0.971396843
built-ruby	1.018460199
built-ruby	1.014156018
built-ruby	1.015829108

-----------------------------------------------------------
vm1_ivar_set

i = 0
while i<30_000_000 # while loop 1
  i += 1
  @a = 1
  @b = 2
end

2.1.1p2	1.052069311
2.1.1p2	1.052366814
2.1.1p2	1.048457306
2.0.0p376	1.141910219
2.0.0p376	1.14028939
2.0.0p376	1.146199165
1.9.3p488	1.036518002
1.9.3p488	1.032183118
1.9.3p488	1.059861002
built-ruby	1.031315235
built-ruby	1.029508294
built-ruby	1.036587923

-----------------------------------------------------------
vm1_length

a = 'abc'
b = [1, 2, 3]
i = 0
while i<30_000_000 # while loop 1
  i += 1
  a.length
  b.length
end


2.1.1p2	1.215648256
2.1.1p2	1.20754927
2.1.1p2	1.225252689
2.0.0p376	1.252672375
2.0.0p376	1.252538389
2.0.0p376	1.252841035
1.9.3p488	1.314562855
1.9.3p488	1.309768918
1.9.3p488	1.291742002
built-ruby	1.19922149
built-ruby	1.196231906
built-ruby	1.20406648

-----------------------------------------------------------
vm1_lvar_init

def m v
  unless v
    # unreachable code
    v1 = v2 = v3 = v4 = v5 = v6 = v7 = v8 = v9 = v10 =
    v11 = v12 = v13 = v14 = v15 = v16 = v17 = v18 = v19 = v20 =
    v21 = v22 = v23 = v24 = v25 = v26 = v27 = v28 = v29 = v30 =
    v31 = v32 = v33 = v34 = v35 = v36 = v37 = v38 = v39 = v40 =
    v41 = v42 = v43 = v44 = v45 = v46 = v47 = v48 = v49 = v50 = 1
  end
end

i = 0

while i<30_000_000 # while loop 1
  i += 1
  m i
end


2.1.1p2	1.976821914
2.1.1p2	1.966430637
2.1.1p2	1.975706512
2.0.0p376	2.133841015
2.0.0p376	2.038357171
2.0.0p376	2.015515552
1.9.3p488	2.509019913
1.9.3p488	2.558454494
1.9.3p488	2.54106034
built-ruby	1.856720929
built-ruby	1.829763498
built-ruby	1.831369791

-----------------------------------------------------------
vm1_lvar_set

i = 0
while i<30_000_000 # while loop 1
  i += 1
  a = b = c = d = e = f = g = h = j = k = l = m = n = o = p = q = r = 1
end

2.1.1p2	2.78234857
2.1.1p2	2.781656456
2.1.1p2	2.817930066
2.0.0p376	3.125980257
2.0.0p376	3.091420035
2.0.0p376	3.081713773
1.9.3p488	2.946405865
1.9.3p488	2.945975754
1.9.3p488	2.948296888
built-ruby	2.761874457
built-ruby	2.765263397
built-ruby	2.760575252

-----------------------------------------------------------
vm1_neq

i = 0
obj1 = Object.new
obj2 = Object.new

while i<30_000_000 # while loop 1
  i += 1
  obj1 != obj2
end

2.1.1p2	1.134039524
2.1.1p2	1.144053988
2.1.1p2	1.13461101
2.0.0p376	1.143132995
2.0.0p376	1.163305096
2.0.0p376	1.143727499
1.9.3p488	1.111422858
1.9.3p488	1.132822294
1.9.3p488	1.152234176
built-ruby	1.145916448
built-ruby	1.150504574
built-ruby	1.138609687

-----------------------------------------------------------
vm1_not

i = 0
obj = Object.new

while i<30_000_000 # while loop 1
  i += 1
  !obj
end

2.1.1p2	0.893561863
2.1.1p2	0.89357606
2.1.1p2	0.891776476
2.0.0p376	0.91875737
2.0.0p376	0.923308629
2.0.0p376	0.920428726
1.9.3p488	0.919896341
1.9.3p488	0.915065609
1.9.3p488	0.915100837
built-ruby	0.886693527
built-ruby	0.886190176
built-ruby	0.889610924

-----------------------------------------------------------
vm1_rescue

i = 0
while i<30_000_000 # while loop 1
  i += 1
  begin
  rescue
  end
end

2.1.1p2	0.759092481
2.1.1p2	0.759342884
2.1.1p2	0.759245095
2.0.0p376	0.779441522
2.0.0p376	0.780104805
2.0.0p376	0.780930914
1.9.3p488	0.779490299
1.9.3p488	0.780039827
1.9.3p488	0.779640503
built-ruby	0.744775164
built-ruby	0.744769599
built-ruby	0.744298279

-----------------------------------------------------------
vm1_simplereturn

def m
  return 1
end
i = 0
while i<30_000_000 # while loop 1
  i += 1
  m
end


2.1.1p2	1.206265083
2.1.1p2	1.207515805
2.1.1p2	1.219910802
2.0.0p376	1.238180477
2.0.0p376	1.244953274
2.0.0p376	1.248884517
1.9.3p488	1.64187214
1.9.3p488	1.640863685
1.9.3p488	1.636683486
built-ruby	1.3133721
built-ruby	1.317810138
built-ruby	1.319138642

-----------------------------------------------------------
vm1_swap

a = 1
b = 2
i = 0
while i<30_000_000 # while loop 1
  i += 1
  a, b = b, a
end


2.1.1p2	0.880896096
2.1.1p2	0.876672556
2.1.1p2	0.873646364
2.0.0p376	0.912451664
2.0.0p376	0.913062674
2.0.0p376	0.915430669
1.9.3p488	0.932161318
1.9.3p488	0.927094527
1.9.3p488	0.957684779
built-ruby	0.864081978
built-ruby	0.864486113
built-ruby	0.864636167

-----------------------------------------------------------
vm1_yield

def m
  i = 0
  while i<30_000_000 # while loop 1
    i += 1
    yield
  end
end

m{}


2.1.1p2	1.262893487
2.1.1p2	1.276419238
2.1.1p2	1.283607227
2.0.0p376	1.306593376
2.0.0p376	1.328032284
2.0.0p376	1.31422982
1.9.3p488	1.188265239
1.9.3p488	1.183254151
1.9.3p488	1.184525146
built-ruby	1.338056172
built-ruby	1.340585393
built-ruby	1.333406474

-----------------------------------------------------------
vm2_array

i = 0
while i<6_000_000 # benchmark loop 2
  i += 1
  a = [1,2,3,4,5,6,7,8,9,10]
end

2.1.1p2	0.874288143
2.1.1p2	0.874015975
2.1.1p2	0.871460985
2.0.0p376	0.861476513
2.0.0p376	0.865633431
2.0.0p376	0.863674112
1.9.3p488	0.728904874
1.9.3p488	0.70332987
1.9.3p488	0.727732195
built-ruby	0.863988986
built-ruby	0.861563981
built-ruby	0.860761263

-----------------------------------------------------------
vm2_bigarray

i = 0
while i<6_000_000 # benchmark loop 2
  i += 1
  a = [
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
    1,2,3,4,5,6,7,8,9,10,
  ]
end

2.1.1p2	6.821100776
2.1.1p2	6.915706147
2.1.1p2	7.262702939
2.0.0p376	10.740991503
2.0.0p376	11.172122418
2.0.0p376	10.702384827
1.9.3p488	8.292044822
1.9.3p488	8.766247302
1.9.3p488	8.298585034
built-ruby	6.619415729
built-ruby	6.68081791
built-ruby	6.695559162

-----------------------------------------------------------
vm2_bighash

i = 0
while i<60_000 # benchmark loop 2
  i += 1
  a = {0=>0, 1=>1, 2=>2, 3=>3, 4=>4, 5=>5, 6=>6, 7=>7, 8=>8, 9=>9, 10=>10, 11=>11, 12=>12, 13=>13, 14=>14, 15=>15, 16=>16, 17=>17, 18=>18, 19=>19, 20=>20, 21=>21, 22=>22, 23=>23, 24=>24, 25=>25, 26=>26, 27=>27, 28=>28, 29=>29, 30=>30, 31=>31, 32=>32, 33=>33, 34=>34, 35=>35, 36=>36, 37=>37, 38=>38, 39=>39, 40=>40, 41=>41, 42=>42, 43=>43, 44=>44, 45=>45, 46=>46, 47=>47, 48=>48, 49=>49, 50=>50, 51=>51, 52=>52, 53=>53, 54=>54, 55=>55, 56=>56, 57=>57, 58=>58, 59=>59, 60=>60, 61=>61, 62=>62, 63=>63, 64=>64, 65=>65, 66=>66, 67=>67, 68=>68, 69=>69, 70=>70, 71=>71, 72=>72, 73=>73, 74=>74, 75=>75, 76=>76, 77=>77, 78=>78, 79=>79, 80=>80, 81=>81, 82=>82, 83=>83, 84=>84, 85=>85, 86=>86, 87=>87, 88=>88, 89=>89, 90=>90, 91=>91, 92=>92, 93=>93, 94=>94, 95=>95, 96=>96, 97=>97, 98=>98, 99=>99, 100=>100, 101=>101, 102=>102, 103=>103, 104=>104, 105=>105, 106=>106, 107=>107, 108=>108, 109=>109, 110=>110, 111=>111, 112=>112, 113=>113, 114=>114, 115=>115, 116=>116, 117=>117, 118=>118, 119=>119, 120=>120, 121=>121, 122=>122, 123=>123, 124=>124, 125=>125, 126=>126, 127=>127, 128=>128, 129=>129, 130=>130, 131=>131, 132=>132, 133=>133, 134=>134, 135=>135, 136=>136, 137=>137, 138=>138, 139=>139, 140=>140, 141=>141, 142=>142, 143=>143, 144=>144, 145=>145, 146=>146, 147=>147, 148=>148, 149=>149, 150=>150, 151=>151, 152=>152, 153=>153, 154=>154, 155=>155, 156=>156, 157=>157, 158=>158, 159=>159, 160=>160, 161=>161, 162=>162, 163=>163, 164=>164, 165=>165, 166=>166, 167=>167, 168=>168, 169=>169, 170=>170, 171=>171, 172=>172, 173=>173, 174=>174, 175=>175, 176=>176, 177=>177, 178=>178, 179=>179, 180=>180, 181=>181, 182=>182, 183=>183, 184=>184, 185=>185, 186=>186, 187=>187, 188=>188, 189=>189, 190=>190, 191=>191, 192=>192, 193=>193, 194=>194, 195=>195, 196=>196, 197=>197, 198=>198, 199=>199, 200=>200, 201=>201, 202=>202, 203=>203, 204=>204, 205=>205, 206=>206, 207=>207, 208=>208, 209=>209, 210=>210, 211=>211, 212=>212, 213=>213, 214=>214, 215=>215, 216=>216, 217=>217, 218=>218, 219=>219, 220=>220, 221=>221, 222=>222, 223=>223, 224=>224, 225=>225, 226=>226, 227=>227, 228=>228, 229=>229, 230=>230, 231=>231, 232=>232, 233=>233, 234=>234, 235=>235, 236=>236, 237=>237, 238=>238, 239=>239, 240=>240, 241=>241, 242=>242, 243=>243, 244=>244, 245=>245, 246=>246, 247=>247, 248=>248, 249=>249, 250=>250, 251=>251, 252=>252, 253=>253, 254=>254, 255=>255, 256=>256, 257=>257, 258=>258, 259=>259, 260=>260, 261=>261, 262=>262, 263=>263, 264=>264, 265=>265, 266=>266, 267=>267, 268=>268, 269=>269, 270=>270, 271=>271, 272=>272, 273=>273, 274=>274, 275=>275, 276=>276, 277=>277, 278=>278, 279=>279, 280=>280, 281=>281, 282=>282, 283=>283, 284=>284, 285=>285, 286=>286, 287=>287, 288=>288, 289=>289, 290=>290, 291=>291, 292=>292, 293=>293, 294=>294, 295=>295, 296=>296, 297=>297, 298=>298, 299=>299, 300=>300, 301=>301, 302=>302, 303=>303, 304=>304, 305=>305, 306=>306, 307=>307, 308=>308, 309=>309, 310=>310, 311=>311, 312=>312, 313=>313, 314=>314, 315=>315, 316=>316, 317=>317, 318=>318, 319=>319, 320=>320, 321=>321, 322=>322, 323=>323, 324=>324, 325=>325, 326=>326, 327=>327, 328=>328, 329=>329, 330=>330, 331=>331, 332=>332, 333=>333, 334=>334, 335=>335, 336=>336, 337=>337, 338=>338, 339=>339, 340=>340, 341=>341, 342=>342, 343=>343, 344=>344, 345=>345, 346=>346, 347=>347, 348=>348, 349=>349, 350=>350, 351=>351, 352=>352, 353=>353, 354=>354, 355=>355, 356=>356, 357=>357, 358=>358, 359=>359, 360=>360, 361=>361, 362=>362, 363=>363, 364=>364, 365=>365, 366=>366, 367=>367, 368=>368, 369=>369, 370=>370, 371=>371, 372=>372, 373=>373, 374=>374, 375=>375, 376=>376, 377=>377, 378=>378, 379=>379, 380=>380, 381=>381, 382=>382, 383=>383, 384=>384, 385=>385, 386=>386, 387=>387, 388=>388, 389=>389, 390=>390, 391=>391, 392=>392, 393=>393, 394=>394, 395=>395, 396=>396, 397=>397, 398=>398, 399=>399, 400=>400, 401=>401, 402=>402, 403=>403, 404=>404, 405=>405, 406=>406, 407=>407, 408=>408, 409=>409, 410=>410, 411=>411, 412=>412, 413=>413, 414=>414, 415=>415, 416=>416, 417=>417, 418=>418, 419=>419, 420=>420, 421=>421, 422=>422, 423=>423, 424=>424, 425=>425, 426=>426, 427=>427, 428=>428, 429=>429, 430=>430, 431=>431, 432=>432, 433=>433, 434=>434, 435=>435, 436=>436, 437=>437, 438=>438, 439=>439, 440=>440, 441=>441, 442=>442, 443=>443, 444=>444, 445=>445, 446=>446, 447=>447, 448=>448, 449=>449, 450=>450, 451=>451, 452=>452, 453=>453, 454=>454, 455=>455, 456=>456, 457=>457, 458=>458, 459=>459, 460=>460, 461=>461, 462=>462, 463=>463, 464=>464, 465=>465, 466=>466, 467=>467, 468=>468, 469=>469, 470=>470, 471=>471, 472=>472, 473=>473, 474=>474, 475=>475, 476=>476, 477=>477, 478=>478, 479=>479, 480=>480, 481=>481, 482=>482, 483=>483, 484=>484, 485=>485, 486=>486, 487=>487, 488=>488, 489=>489, 490=>490, 491=>491, 492=>492, 493=>493, 494=>494, 495=>495, 496=>496, 497=>497, 498=>498, 499=>499, 500=>500,}
end

2.1.1p2	5.757441246
2.1.1p2	5.804874467
2.1.1p2	5.808462803
2.0.0p376	5.058966834
2.0.0p376	5.312727486
2.0.0p376	5.052674186
1.9.3p488	5.272737184
1.9.3p488	5.234747717
1.9.3p488	5.196921546
built-ruby	5.825274713
built-ruby	5.902356944
built-ruby	5.857918796

-----------------------------------------------------------
vm2_case

i = 0
while i<6_000_000 # while loop 2
  case :foo
  when :bar
    raise
  when :baz
    raise
  when :boo
    raise
  when :foo
    i += 1
  end
end


2.1.1p2	0.268417213
2.1.1p2	0.268507097
2.1.1p2	0.268839224
2.0.0p376	0.274659667
2.0.0p376	0.271154611
2.0.0p376	0.271541093
1.9.3p488	0.312792612
1.9.3p488	0.312448731
1.9.3p488	0.318117014
built-ruby	0.259396437
built-ruby	0.262179619
built-ruby	0.258107754

-----------------------------------------------------------
vm2_defined_method

class Object
  define_method(:m){}
end

i = 0
while i<6_000_000 # benchmark loop 2
  i += 1
  m; m; m; m; m; m; m; m;
end

2.1.1p2	3.072929548
2.1.1p2	3.081009046
2.1.1p2	3.059344045
2.0.0p376	2.880023904
2.0.0p376	2.867644564
2.0.0p376	2.864467093
1.9.3p488	3.493825126
1.9.3p488	3.40409348
1.9.3p488	3.394098683
built-ruby	3.028583306
built-ruby	3.014979996
built-ruby	3.131942448

-----------------------------------------------------------
vm2_dstr

i = 0
x = y = 'z'
while i<6_000_000 # benchmark loop 2
  i += 1
  str = "foo#{x}bar#{y}baz"
end

2.1.1p2	1.998616849
2.1.1p2	2.000880212
2.1.1p2	1.990305893
2.0.0p376	1.600745728
2.0.0p376	1.590364401
2.0.0p376	1.661487798
1.9.3p488	2.333501402
1.9.3p488	2.317273951
1.9.3p488	2.313784883
built-ruby	1.851863922
built-ruby	1.865102844
built-ruby	1.855898979

-----------------------------------------------------------
vm2_eval

i = 0
while i<6_000_000 # benchmark loop 2
  i += 1
  eval("1")
end


2.1.1p2	15.642602638
2.1.1p2	15.304773211
2.1.1p2	15.459043563
2.0.0p376	17.051293951
2.0.0p376	16.126888435
2.0.0p376	16.988656324
1.9.3p488	12.61572308
1.9.3p488	12.744858869
1.9.3p488	12.270834792
built-ruby	15.641400906
built-ruby	15.436924347
built-ruby	15.966145433

-----------------------------------------------------------
vm2_method

def m
  nil
end

i = 0
while i<6_000_000 # benchmark loop 2
  i += 1
  m; m; m; m; m; m; m; m;
end

2.1.1p2	1.198099084
2.1.1p2	1.188201978
2.1.1p2	1.235612262
2.0.0p376	1.2250654
2.0.0p376	1.230205265
2.0.0p376	1.247406952
1.9.3p488	1.830268384
1.9.3p488	1.988296474
1.9.3p488	1.825144726
built-ruby	1.30971963
built-ruby	1.312656953
built-ruby	1.310389838

-----------------------------------------------------------
vm2_method_missing

class C
  def method_missing mid
  end
end

obj = C.new

i = 0
while i<6_000_000 # benchmark loop 2
  i += 1
  obj.m; obj.m; obj.m; obj.m; obj.m; obj.m; obj.m; obj.m;
end

2.1.1p2	2.079806573
2.1.1p2	2.052615797
2.1.1p2	2.060783485
2.0.0p376	2.074575985
2.0.0p376	2.173368359
2.0.0p376	2.102542258
1.9.3p488	4.125095445
1.9.3p488	4.03075505
1.9.3p488	4.038664682
built-ruby	2.190290561
built-ruby	2.152490204
built-ruby	2.194194022

-----------------------------------------------------------
vm2_method_with_block

def m
  nil
end

i = 0
while i<6_000_000 # benchmark loop 2
  i += 1
  m{}; m{}; m{}; m{}; m{}; m{}; m{}; m{};
end

2.1.1p2	1.4537331
2.1.1p2	1.450951909
2.1.1p2	1.452868422
2.0.0p376	1.498316807
2.0.0p376	1.469483767
2.0.0p376	1.474972516
1.9.3p488	1.827441319
1.9.3p488	1.85967307
1.9.3p488	1.82230543
built-ruby	1.544520226
built-ruby	1.582808759
built-ruby	1.545401723

-----------------------------------------------------------
vm2_mutex

require 'thread'

m = Mutex.new

i = 0
while i<6_000_000 # benchmark loop 2
  i += 1
  m.synchronize{}
end

2.1.1p2	0.88527588
2.1.1p2	0.884271978
2.1.1p2	0.871235841
2.0.0p376	0.867655352
2.0.0p376	0.867586029
2.0.0p376	0.848800957
1.9.3p488	1.058286809
1.9.3p488	1.04159052
1.9.3p488	1.037831386
built-ruby	0.869592095
built-ruby	0.870447652
built-ruby	0.872990696

-----------------------------------------------------------
vm2_poly_method

class C1
  def m
    1
  end
end
class C2
  def m
    2
  end
end

o1 = C1.new
o2 = C2.new

i = 0
while i<6_000_000 # benchmark loop 2
  o = (i % 2 == 0) ? o1 : o2
  o.m; o.m; o.m; o.m; o.m; o.m; o.m; o.m
  i += 1
end

2.1.1p2	2.186947316
2.1.1p2	2.179519991
2.1.1p2	2.189759818
2.0.0p376	2.200213983
2.0.0p376	2.235718669
2.0.0p376	2.22744687
1.9.3p488	2.449437757
1.9.3p488	2.472857786
1.9.3p488	2.459590513
built-ruby	2.293849072
built-ruby	2.241126432
built-ruby	2.248085544

-----------------------------------------------------------
vm2_poly_method_ov

class C1
  def m
    1
  end
end
class C2
  def m
    2
  end
end

o1 = C1.new
o2 = C2.new

i = 0
while i<6_000_000 # benchmark loop 2
  o = (i % 2 == 0) ? o1 : o2
#  o.m; o.m; o.m; o.m; o.m; o.m; o.m; o.m
  i += 1
end

2.1.1p2	0.355108168
2.1.1p2	0.359044975
2.1.1p2	0.356415969
2.0.0p376	0.372607894
2.0.0p376	0.373988015
2.0.0p376	0.375115661
1.9.3p488	0.364267318
1.9.3p488	0.364659838
1.9.3p488	0.36261723
built-ruby	0.343648652
built-ruby	0.341193803
built-ruby	0.346102468

-----------------------------------------------------------
vm2_proc

def m &b
  b
end

pr = m{
  a = 1
}

i = 0
while i<6_000_000 # benchmark loop 2
  i += 1
  pr.call
end


2.1.1p2	0.627199497
2.1.1p2	0.61373327
2.1.1p2	0.61402351
2.0.0p376	0.617743012
2.0.0p376	0.595287977
2.0.0p376	0.618821465
1.9.3p488	0.665604933
1.9.3p488	0.666784071
1.9.3p488	0.674036818
built-ruby	0.634933562
built-ruby	0.633283009
built-ruby	0.597343201

-----------------------------------------------------------
vm2_raise1

def rec n
  if n > 0
    rec n-1
  else
    raise
  end
end

i = 0
while i<6_000_000 # benchmark loop 2
  i += 1

  begin
    rec 1
  rescue
    # ignore
  end
end

2.1.1p2	6.901207356
2.1.1p2	6.764197701
2.1.1p2	6.944549246
2.0.0p376	6.139699901
2.0.0p376	6.152858066
2.0.0p376	6.12463819
1.9.3p488	14.226125092
1.9.3p488	14.289234802
1.9.3p488	14.208513651
built-ruby	7.24430192
built-ruby	7.215944933
built-ruby	7.195592247

-----------------------------------------------------------
vm2_raise2

def rec n
  if n > 0
    rec n-1
  else
    raise
  end
end

i = 0
while i<6_000_000 # benchmark loop 2
  i += 1

  begin
    rec 10
  rescue
    # ignore
  end
end

2.1.1p2	9.505189419
2.1.1p2	9.373688566
2.1.1p2	9.824068669
2.0.0p376	9.0790824
2.0.0p376	9.062157371
2.0.0p376	9.059955623
1.9.3p488	39.847553234
1.9.3p488	40.066859636
1.9.3p488	40.101037147
built-ruby	9.958132085
built-ruby	9.997546175
built-ruby	10.15853801

-----------------------------------------------------------
vm2_regexp

i = 0
str = 'xxxhogexxx'
while i<6_000_000 # benchmark loop 2
  /hoge/ =~ str
  i += 1
end

2.1.1p2	1.330653559
2.1.1p2	1.335640029
2.1.1p2	1.414009063
2.0.0p376	1.396003451
2.0.0p376	1.399842927
2.0.0p376	1.395599231
1.9.3p488	1.266103704
1.9.3p488	1.241384498
1.9.3p488	1.25015508
built-ruby	1.322830446
built-ruby	1.313156547
built-ruby	1.320252781

-----------------------------------------------------------
vm2_send

class C
  def m
  end
end

o = C.new

i = 0
while i<6_000_000 # benchmark loop 2
  i += 1
  o.__send__ :m
end

2.1.1p2	0.46646592
2.1.1p2	0.460639701
2.1.1p2	0.461177917
2.0.0p376	0.458428624
2.0.0p376	0.462640307
2.0.0p376	0.464813666
1.9.3p488	0.422702659
1.9.3p488	0.420901896
1.9.3p488	0.419664655
built-ruby	0.456363975
built-ruby	0.459375416
built-ruby	0.462872325

-----------------------------------------------------------
vm2_super


class C
  def m
    1
  end
end

class CC < C
  def m
    super()
  end
end

obj = CC.new

i = 0
while i<6_000_000 # benchmark loop 2
  obj.m
  i += 1
end

2.1.1p2	0.547811771
2.1.1p2	0.541892969
2.1.1p2	0.571267653
2.0.0p376	0.554027362
2.0.0p376	0.547500198
2.0.0p376	0.546790028
1.9.3p488	0.613226172
1.9.3p488	0.633516832
1.9.3p488	0.611893755
built-ruby	0.565999865
built-ruby	0.563941148
built-ruby	0.569990488

-----------------------------------------------------------
vm2_unif1

i = 0
def m a, b
end

while i<6_000_000 # benchmark loop 2
  i += 1
  m 100, 200
end

2.1.1p2	0.301481546
2.1.1p2	0.299129848
2.1.1p2	0.309822083
2.0.0p376	0.307895147
2.0.0p376	0.405163863
2.0.0p376	0.301921545
1.9.3p488	0.381009369
1.9.3p488	0.385739537
1.9.3p488	0.383167656
built-ruby	0.305110677
built-ruby	0.305335414
built-ruby	0.305867819

-----------------------------------------------------------
vm2_zsuper

i = 0

class C
  def m a
    1
  end
end

class CC < C
  def m a
    super
  end
end

obj = CC.new

while i<6_000_000 # benchmark loop 2
  obj.m 10
  i += 1
end

2.1.1p2	0.560940253
2.1.1p2	0.581526691
2.1.1p2	0.559718381
2.0.0p376	0.569571949
2.0.0p376	0.572774038
2.0.0p376	0.565835324
1.9.3p488	0.635059995
1.9.3p488	0.635423184
1.9.3p488	0.643495713
built-ruby	0.597480961
built-ruby	0.587794762
built-ruby	0.581698298

-----------------------------------------------------------
vm3_backtrace

# get last backtrace

begin
  caller(0, 0)
rescue ArgumentError
  alias caller_orig caller
  def caller lev, n
    caller_orig(lev)[0..n]
  end
end

def rec n
  if n < 0
    100_000.times{
      caller(0, 1)
    }
  else
    rec(n-1)
  end
end

rec 50

2.1.1p2	0.210785361
2.1.1p2	0.208830826
2.1.1p2	0.208901973
2.0.0p376	0.213054421
2.0.0p376	0.212734285
2.0.0p376	0.213147798
1.9.3p488	2.49715292
1.9.3p488	2.48900489
1.9.3p488	2.505606498
built-ruby	0.188435989
built-ruby	0.188446543
built-ruby	0.188674263

-----------------------------------------------------------
vm3_clearmethodcache

i = 0
while i<200_000
  i += 1

  Class.new{
    def m; end
  }
end

2.1.1p2	0.489506079
2.1.1p2	0.488522687
2.1.1p2	0.488236333
2.0.0p376	0.637807478
2.0.0p376	0.645163829
2.0.0p376	0.636699478
1.9.3p488	0.360404926
1.9.3p488	0.376059481
1.9.3p488	0.362159834
built-ruby	0.47238072
built-ruby	0.468968463
built-ruby	0.47166797

-----------------------------------------------------------
vm3_gc

#! /usr/bin/ruby
5000.times do
  100.times do
    {"xxxx"=>"yyyy"}
  end
  GC.start
end

2.1.1p2	2.127220398
2.1.1p2	2.190392536
2.1.1p2	2.207169653
2.0.0p376	2.298974042
2.0.0p376	2.351099927
2.0.0p376	2.321696636
1.9.3p488	1.371684676
1.9.3p488	1.361009398
1.9.3p488	1.377756902
built-ruby	0.759132126
built-ruby	0.749746738
built-ruby	0.791810294

-----------------------------------------------------------
vm_thread_alive_check1

5_000.times{
  t = Thread.new{}
  while t.alive?
    Thread.pass
  end
}

2.1.1p2	0.144084783
2.1.1p2	0.141857283
2.1.1p2	0.138871395
2.0.0p376	0.14303952
2.0.0p376	0.136445913
2.0.0p376	0.136892722
1.9.3p488	0.150704841
1.9.3p488	0.148676542
1.9.3p488	0.148839738
built-ruby	0.134061265
built-ruby	0.130402532
built-ruby	0.12696098

-----------------------------------------------------------
vm_thread_create_join

i = 0
while i<100_000 # benchmark loop 3
  i += 1
  Thread.new{
  }.join
end

2.1.1p2	1.484909564
2.1.1p2	1.456710445
2.1.1p2	1.482462978
2.0.0p376	1.481957683
2.0.0p376	1.464745206
2.0.0p376	1.479011513
1.9.3p488	1.407045713
1.9.3p488	1.385975604
1.9.3p488	1.403015744
built-ruby	1.44334212
built-ruby	1.464553632
built-ruby	1.441031155

-----------------------------------------------------------
vm_thread_mutex1

# one thread, one mutex (no contention)

require 'thread'
m = Mutex.new
r = 0
max = 2000
lmax = max * max
(1..1).map{
  Thread.new{
    i = 0
    while i<lmax
      i += 1
      m.synchronize{
        r += 1
      }
    end
  }
}.each{|e|
  e.join
}
raise r.to_s if r != max * max

2.1.1p2	0.661706083
2.1.1p2	0.655239639
2.1.1p2	0.650353601
2.0.0p376	0.642376354
2.0.0p376	0.663177813
2.0.0p376	0.657788643
1.9.3p488	0.771526368
1.9.3p488	0.774828386
1.9.3p488	0.775744727
built-ruby	0.6618067
built-ruby	0.649243243
built-ruby	0.652589787

-----------------------------------------------------------
vm_thread_mutex2

# two threads, one mutex

require 'thread'
m = Mutex.new
r = 0
max = 2000
lmax = (max * max)/2
(1..2).map{
  Thread.new{
    i = 0
    while i<lmax
      i += 1
      m.synchronize{
        r += 1
      }
    end
  }
}.each{|e|
  e.join
}
raise r.to_s if r != max * max

2.1.1p2	2.152157181
2.1.1p2	1.022791344
2.1.1p2	2.372685178
2.0.0p376	2.732041626
2.0.0p376	0.647916314
2.0.0p376	2.076178747
1.9.3p488	2.399297434
1.9.3p488	2.419817615
1.9.3p488	2.56450371
built-ruby	2.122212945
built-ruby	2.276880033
built-ruby	3.106486969

-----------------------------------------------------------
vm_thread_mutex3

# 1000 threads, one mutex

require 'thread'
m = Mutex.new
r = 0
max = 2000
(1..max).map{
  Thread.new{
    i = 0
    while i<max
      i += 1
      m.synchronize{
        r += 1
      }
    end
  }
}.each{|e|
  e.join
}
raise r.to_s if r != max * max

2.1.1p2	24.825039158
2.1.1p2	23.548028047
2.1.1p2	24.813187526
2.0.0p376	23.87193864
2.0.0p376	22.323857467
2.0.0p376	25.515747928
1.9.3p488	1.994415896
1.9.3p488	1.970488332
1.9.3p488	1.938751228
built-ruby	24.319403997
built-ruby	25.437533118
built-ruby	20.687078531

-----------------------------------------------------------
vm_thread_pass

# Plenty Thtread.pass
# A performance may depend on GVL implementation.

tmax = (ARGV.shift || 2).to_i
lmax = 200_000 / tmax

(1..tmax).map{
  Thread.new{
    lmax.times{
      Thread.pass
    }
  }
}.each{|t| t.join}



2.1.1p2	0.474100852
2.1.1p2	0.533051863
2.1.1p2	0.450143559
2.0.0p376	0.468503401
2.0.0p376	0.579729039
2.0.0p376	0.450585904
1.9.3p488	0.529511932
1.9.3p488	0.48707757
1.9.3p488	0.517994803
built-ruby	0.493729446
built-ruby	0.443490044
built-ruby	0.417942616

-----------------------------------------------------------
vm_thread_pass_flood

1000.times{
  Thread.new{loop{Thread.pass}}
}

i = 0
while i<10000
  i += 1
end

2.1.1p2	0.136109911
2.1.1p2	0.135562026
2.1.1p2	0.130535164
2.0.0p376	0.485091799
2.0.0p376	0.44208715
2.0.0p376	0.471618098
1.9.3p488	0.307770367
1.9.3p488	0.251522881
1.9.3p488	0.253383106
built-ruby	0.114416791
built-ruby	0.109460752
built-ruby	0.119409074

-----------------------------------------------------------
vm_thread_pipe

# Mesure small and plenty pipe read/write.
# A performance may depend on GVL implementation.

lmax = 100_000
r, w = IO.pipe
[Thread.new{
  lmax.times{
    w.write('a')
  }
  p "w:exit"
}, Thread.new{
  lmax.times{
    r.read(1)
  }
  p "r:exit"
}].each{|t| t.join}


2.1.1p2	0.412041652
2.1.1p2	0.402737398
2.1.1p2	0.405671865
2.0.0p376	0.42112308
2.0.0p376	0.400260527
2.0.0p376	0.425199599
1.9.3p488	0.681126587
1.9.3p488	0.741039475
1.9.3p488	0.854447475
built-ruby	0.44066309
built-ruby	0.424523853
built-ruby	0.443117426

-----------------------------------------------------------
vm_thread_queue

require 'thread'

n = 1_000_000
q = Queue.new
consumer = Thread.new{
  while q.pop
    # consuming
  end
}

producer = Thread.new{
  n.times{
    q.push true
  }
  q.push nil
}

consumer.join

2.1.1p2	0.182447125
2.1.1p2	0.170635522
2.1.1p2	0.167987649
2.0.0p376	5.32224477
2.0.0p376	5.126583652
2.0.0p376	5.591476905
1.9.3p488	53.438007747
1.9.3p488	51.703505298
1.9.3p488	51.633497136
built-ruby	0.157051289
built-ruby	0.159704114
built-ruby	0.157137553

-----------------------------------------------------------
raw data:

[["app_answer",
  [[0.07161445, 0.056695999, 0.056208697],
   [0.067756399, 0.053703642, 0.053562691],
   [0.062545535, 0.05263223, 0.05277262],
   [0.051903595, 0.046996281, 0.047347993]]],
 ["app_aobench",
  [[46.180319972, 47.013529551, 46.880906602],
   [51.768977437, 51.823987971, 51.919797698],
   [90.466863972, 91.208989492, 90.455036927],
   [47.893013053, 48.586430475, 49.105717176]]],
 ["app_erb",
  [[1.063233305, 1.054361609, 1.074642557],
   [1.051766054, 1.045051676, 1.044243652],
   [1.061223452, 1.062661017, 1.063852182],
   [0.994321865, 0.979415881, 0.968504756]]],
 ["app_factorial",
  [[0.848569184, 0.841120943, 0.838159162],
   [1.130598327, 1.132891215, 1.13561161],
   [0.96223453, 0.9648005, 0.964433566],
   [0.831117075, 0.830480607, 0.832716269]]],
 ["app_fib",
  [[0.452195343, 0.450231669, 0.450500693],
   [0.472044455, 0.466501454, 0.467884414],
   [0.632737834, 0.632928776, 0.634119869],
   [0.493996381, 0.496056417, 0.489163296]]],
 ["app_mandelbrot",
  [[1.067478392, 1.058915743, 1.083456093],
   [1.136318324, 1.128894479, 1.131092157],
   [1.757773868, 1.761934989, 1.805504491],
   [1.083697361, 1.10629992, 1.093600547]]],
 ["app_pentomino",
  [[15.995002055, 16.055379777, 16.044610017],
   [16.292415654, 16.171820372, 16.199375931],
   [16.303151904, 16.164081259, 16.290488878],
   [16.397066988, 16.437248011, 16.530455574]]],
 ["app_raise",
  [[0.357093104, 0.33194047, 0.33188944],
   [0.291463937, 0.291419411, 0.294647499],
   [0.440765794, 0.428953317, 0.437773828],
   [0.339349344, 0.341979158, 0.341383866]]],
 ["app_strconcat",
  [[1.285189545, 1.261374515, 1.298565928],
   [1.203356007, 1.227771628, 1.211296518],
   [1.341268823, 1.353948404, 1.342560453],
   [1.252123552, 1.262034143, 1.254783751]]],
 ["app_tak",
  [[0.681942297, 0.656916703, 0.665664502],
   [0.678022839, 0.680031009, 0.68248588],
   [0.959567017, 0.952134896, 0.951633643],
   [0.721588707, 0.699397175, 0.707075357]]],
 ["app_tarai",
  [[0.552609179, 0.548298297, 0.541099116],
   [0.567492216, 0.569595295, 0.573119809],
   [0.76568104, 0.753496201, 0.755686649],
   [0.579698914, 0.581843772, 0.597094004]]],
 ["app_uri",
  [[0.673334885, 0.681709478, 0.671267009],
   [0.724293293, 0.711662347, 0.711214659],
   [0.64775252, 0.635366347, 0.635767108],
   [0.65945548, 0.660747279, 0.659292316]]],
 ["hash_flatten",
  [[0.676942177, 0.678966748, 0.692348241],
   [2.996892543, 2.98562122, 3.009410585],
   [3.093214421, 3.085934919, 3.096551174],
   [0.659766687, 0.665606795, 0.661024192]]],
 ["hash_keys",
  [[0.307380552, 0.301255109, 0.300064774],
   [3.131493429, 3.132781908, 3.135714786],
   [3.017040395, 3.015491366, 3.033873313],
   [0.290420019, 0.289518501, 0.292021247]]],
 ["hash_shift",
  [[0.044521522, 0.044151167, 0.044357052],
   [4.91929007, 5.9257935, 5.982457902],
   [0.030041822, 0.030104515, 0.029793729],
   [0.03249117, 0.032224895, 0.032618757]]],
 ["hash_values",
  [[0.298060113, 0.298946174, 0.297877631],
   [3.111033106, 3.098875485, 3.129539484],
   [2.999499302, 3.046080582, 3.026596242],
   [0.29573617, 0.283734572, 0.284149398]]],
 ["io_file_create",
  [[2.084113952, 2.045791308, 2.07894159],
   [1.884557194, 1.931733403, 1.912010711],
   [1.876735958, 1.870241223, 1.895507575],
   [1.911648278, 1.932849481, 1.912759656]]],
 ["io_file_read",
  [[1.075080484, 1.034462944, 1.164349082],
   [2.104899623, 2.122485171, 2.128855883],
   [2.12885553, 2.219270126, 2.159325741],
   [1.005803636, 0.995624974, 0.993127872]]],
 ["io_file_write",
  [[0.870453123, 0.859926865, 0.870971417],
   [0.845280235, 0.846731398, 0.864715575],
   [0.805428507, 0.815632428, 0.810791401],
   [0.856652809, 0.901546811, 0.861546362]]],
 ["io_select",
  [[1.264363964, 1.262544642, 1.270771677],
   [1.225958135, 1.223318471, 1.228220427],
   [1.106577363, 1.101158537, 1.098293115],
   [1.223211389, 1.230193013, 1.228985774]]],
 ["io_select2",
  [[1.432572655, 1.432579402, 1.431788357],
   [1.384076772, 1.403502155, 1.391903089],
   [1.280592686, 1.375832291, 1.274943212],
   [1.396680973, 1.381019534, 1.384775247]]],
 ["io_select3",
  [[0.038069908, 0.037329258, 0.037066111],
   [0.034822925, 0.035453498, 0.035481918],
   [0.023484455, 0.023609168, 0.022964358],
   [0.025406822, 0.02487105, 0.025151997]]],
 ["loop_for",
  [[1.264983996, 1.205215452, 1.19201663],
   [1.214261742, 1.228141685, 1.255142715],
   [1.297169712, 1.312113978, 1.298199031],
   [1.220279195, 1.217505769, 1.218888754]]],
 ["loop_generator",
  [[0.417006864, 0.413154432, 0.414459501],
   [0.415401364, 0.414662839, 0.412945003],
   [0.412258619, 0.412432431, 0.409762937],
   [0.406731, 0.411253807, 0.409545618]]],
 ["loop_times",
  [[1.101816848, 1.100772321, 1.098617932],
   [1.132467082, 1.112714424, 1.113407555],
   [1.233724689, 1.169472139, 1.170214328],
   [1.197629936, 1.17879239, 1.134669035]]],
 ["loop_whileloop",
  [[0.60555732, 0.60264823, 0.604484804],
   [0.620912262, 0.620958468, 0.621653348],
   [0.619166145, 0.61874923, 0.618302698],
   [0.596915708, 0.604007585, 0.596523258]]],
 ["loop_whileloop2",
  [[0.141377557, 0.13972336, 0.139450299],
   [0.140181324, 0.140327641, 0.141528063],
   [0.13718052, 0.131704421, 0.131385137],
   [0.129041065, 0.130931998, 0.129792427]]],
 ["so_ackermann",
  [[0.555733106, 0.549695358, 0.554712228],
   [0.578662368, 0.58258555, 0.58248392],
   [0.724386891, 0.723351486, 0.726466857],
   [0.592565876, 0.600503542, 0.595485997]]],
 ["so_array",
  [[0.826826781, 0.828740791, 0.842492361],
   [1.024685809, 1.003268905, 1.01223902],
   [1.238463353, 1.251710208, 1.245088834],
   [0.8626811, 0.861685777, 0.882931192]]],
 ["so_binary_trees",
  [[5.936390596, 5.888435169, 5.889338682],
   [6.484615168, 6.443247128, 6.484145267],
   [7.936166118, 7.908431049, 7.928245062],
   [6.293140654, 6.273179398, 6.318781854]]],
 ["so_concatenate",
  [[4.240087236, 4.331015265, 4.274741422],
   [3.71331407, 3.754861267, 3.884712726],
   [3.889846121, 3.84248544, 3.832180389],
   [4.447907092, 4.434787722, 4.498798001]]],
 ["so_count_words",
  [[0.246779318, 0.23322264, 0.232460807],
   [0.237323331, 0.233553006, 0.230535182],
   [0.229639066, 0.227008724, 0.22751194],
   [0.237569436, 0.238114244, 0.235850607]]],
 ["so_exception",
  [[0.325388717, 0.325057268, 0.322413465],
   [0.291836899, 0.281782459, 0.276928504],
   [0.860840345, 0.854422178, 0.856075272],
   [0.316294083, 0.325901122, 0.329178749]]],
 ["so_fannkuch",
  [[1.146167175, 1.131824456, 1.123389168],
   [1.190577911, 1.173011017, 1.222037731],
   [1.182416891, 1.18504069, 1.181296606],
   [1.064609471, 1.044752546, 1.057923539]]],
 ["so_fasta",
  [[1.942103771, 1.941966313, 1.934466994],
   [1.978399561, 1.97606602, 1.981715455],
   [2.210672104, 2.212052808, 2.214474129],
   [1.964916476, 1.959252152, 1.972785085]]],
 ["so_k_nucleotide",
  [[1.273850339, 1.265333786, 1.271498009],
   [1.379525667, 1.383376617, 1.397264524],
   [1.44410359, 1.437168935, 1.431846302],
   [1.323702097, 1.306156321, 1.308268933]]],
 ["so_lists",
  [[0.556018272, 0.543298518, 0.55215019],
   [0.545966734, 0.548046187, 0.542319835],
   [0.778421954, 0.775751105, 0.766763313],
   [0.512853457, 0.5194303, 0.523478016]]],
 ["so_mandelbrot",
  [[2.060143683, 2.064888202, 2.089517648],
   [2.094807149, 2.122010965, 2.088683758],
   [4.27215174, 4.299708441, 4.294594516],
   [2.045011079, 2.042130741, 2.045534524]]],
 ["so_matrix",
  [[0.58008666, 0.571212232, 0.580901858],
   [0.570989161, 0.567225173, 0.575199769],
   [0.761310716, 0.74904347, 0.775379632],
   [0.593705656, 0.5731564, 0.560781746]]],
 ["so_meteor_contest",
  [[3.077131799, 2.955562836, 3.046814941],
   [3.476820479, 3.476541584, 3.48787717],
   [4.129935474, 4.129596154, 4.140483484],
   [3.169448614, 3.131979457, 3.138839768]]],
 ["so_nbody",
  [[1.337051469, 1.318095332, 1.327789653],
   [1.364106408, 1.363850084, 1.362785593],
   [3.280226033, 3.181781751, 3.173823337],
   [1.344392865, 1.366482906, 1.352117001]]],
 ["so_nested_loop",
  [[1.043109006, 1.04875546, 1.042104108],
   [1.050889156, 1.054536712, 1.065242671],
   [1.141826801, 1.103084116, 1.100470206],
   [1.119196947, 1.088138852, 1.089133556]]],
 ["so_nsieve",
  [[1.862842711, 1.856037969, 1.874550231],
   [2.072198453, 2.083547824, 2.118317449],
   [2.5084232, 2.517854763, 2.511183343],
   [1.809183842, 1.808480077, 1.806064479]]],
 ["so_nsieve_bits",
  [[2.315777357, 2.265442666, 2.289582117],
   [2.245906781, 2.256440352, 2.277092141],
   [2.519811231, 2.51784622, 2.54408915],
   [2.272965052, 2.285362301, 2.263050009]]],
 ["so_object",
  [[0.701306889, 0.695321153, 0.69648523],
   [0.766356714, 0.76327134, 0.761880767],
   [0.828286061, 0.842289449, 0.830387654],
   [0.717265502, 0.717468459, 0.714658146]]],
 ["so_partial_sums",
  [[1.828271948, 1.831203115, 1.833619587],
   [1.851996506, 1.890893315, 1.899806002],
   [4.056615998, 4.078569385, 4.111150782],
   [1.856624521, 1.848451891, 1.845182478]]],
 ["so_pidigits",
  [[0.555615786, 0.546697736, 0.547382519],
   [0.709998677, 0.714492918, 0.712472939],
   [0.612329516, 0.612637053, 0.613134267],
   [0.493146282, 0.493823501, 0.493427098]]],
 ["so_random",
  [[0.520703109, 0.510913006, 0.510056372],
   [0.526987447, 0.52327142, 0.523104733],
   [0.887510263, 0.913544793, 0.882488864],
   [0.517508249, 0.523920966, 0.515691037]]],
 ["so_reverse_complement",
  [[1.305916953, 2.265054004, 1.822650533],
   [1.976385712, 1.992948438, 2.038749118],
   [1.822591654, 1.853377638, 1.830097186],
   [1.910687143, 1.901452372, 1.891457887]]],
 ["so_sieve",
  [[0.617184921, 0.622036936, 0.618206849],
   [0.715317233, 0.709361485, 0.714483321],
   [0.840763793, 0.834929173, 0.834748767],
   [0.597862855, 0.59153191, 0.588468323]]],
 ["so_spectralnorm",
  [[1.850613653, 1.843206465, 1.851691918],
   [1.90098281, 1.886036809, 1.940763777],
   [3.079652843, 3.081073181, 3.088303859],
   [1.982550399, 1.982257948, 2.016638799]]],
 ["vm1_attr_ivar",
  [[1.409501514, 1.412510847, 1.413082087],
   [1.448197691, 1.453029974, 1.448789519],
   [2.322807771, 2.333871521, 2.321210116],
   [1.435117318, 1.426191909, 1.430098101]]],
 ["vm1_attr_ivar_set",
  [[1.544271134, 1.560318882, 1.539478458],
   [1.705332635, 1.702858489, 1.70591799],
   [2.659590761, 2.657678174, 2.66401227],
   [1.580836895, 1.570063354, 1.572116217]]],
 ["vm1_block",
  [[2.027474208, 2.015619852, 2.031384068],
   [2.123423401, 2.061819708, 2.063553501],
   [2.295317418, 2.24013797, 2.23835669],
   [2.215372397, 2.250257682, 2.214198491]]],
 ["vm1_const",
  [[0.881789307, 0.882730331, 0.881487637],
   [0.920451018, 0.920934651, 0.918383514],
   [0.920411176, 0.924041291, 0.919675464],
   [0.880008471, 0.88010216, 0.880544008]]],
 ["vm1_ensure",
  [[0.656150322, 0.655332181, 0.655937213],
   [0.667367947, 0.670309181, 0.666726669],
   [0.666402253, 0.669295379, 0.666013928],
   [0.642919439, 0.659550725, 0.653741877]]],
 ["vm1_float_simple",
  [[4.827171868, 4.802183205, 4.724098101],
   [4.574588228, 4.55461964, 4.509852549],
   [9.30687233, 9.28117027, 9.255304719],
   [4.669843545, 4.609064616, 4.643201517]]],
 ["vm1_gc_short_lived",
  [[10.585113718, 10.964990482, 10.827571894],
   [11.245535617, 11.257200715, 11.30997148],
   [10.393903832, 10.366449899, 10.372020497],
   [10.892790128, 10.902945412, 10.93803811]]],
 ["vm1_gc_short_with_complex_long",
  [[11.85656024, 12.559234527, 12.471197195],
   [15.682867214, 15.487801102, 15.411736612],
   [14.9093197, 14.865838933, 15.266519983],
   [12.969565326, 12.961450346, 13.006964712]]],
 ["vm1_gc_short_with_long",
  [[11.565594877, 11.810769512, 11.782698653],
   [11.506701494, 11.51405556, 11.833478699],
   [13.768885383, 13.556617292, 13.742729596],
   [11.474787459, 11.515869424, 11.472725112]]],
 ["vm1_gc_short_with_symbol",
  [[10.302245109, 10.843522858, 10.807801746],
   [12.757823554, 12.778705022, 12.721510023],
   [16.379989977, 16.040176199, 16.438849341],
   [11.559599339, 11.479860124, 11.332841803]]],
 ["vm1_gc_wb_ary",
  [[1.284043953, 1.272226923, 1.273858504],
   [1.61952637, 1.62739005, 1.620812514],
   [2.028061662, 2.038311126, 2.034058548],
   [1.274262665, 1.266927678, 1.264216429]]],
 ["vm1_gc_wb_obj",
  [[1.242712392, 1.237639985, 1.239585049],
   [1.157790336, 1.182896289, 1.175596527],
   [1.650151729, 1.701067733, 1.723459],
   [1.22605842, 1.223808326, 1.234651391]]],
 ["vm1_ivar",
  [[1.051577045, 1.024985434, 1.026588399],
   [1.084304551, 1.089094486, 1.084993288],
   [0.969944283, 0.972278355, 0.971396843],
   [1.018460199, 1.014156018, 1.015829108]]],
 ["vm1_ivar_set",
  [[1.052069311, 1.052366814, 1.048457306],
   [1.141910219, 1.14028939, 1.146199165],
   [1.036518002, 1.032183118, 1.059861002],
   [1.031315235, 1.029508294, 1.036587923]]],
 ["vm1_length",
  [[1.215648256, 1.20754927, 1.225252689],
   [1.252672375, 1.252538389, 1.252841035],
   [1.314562855, 1.309768918, 1.291742002],
   [1.19922149, 1.196231906, 1.20406648]]],
 ["vm1_lvar_init",
  [[1.976821914, 1.966430637, 1.975706512],
   [2.133841015, 2.038357171, 2.015515552],
   [2.509019913, 2.558454494, 2.54106034],
   [1.856720929, 1.829763498, 1.831369791]]],
 ["vm1_lvar_set",
  [[2.78234857, 2.781656456, 2.817930066],
   [3.125980257, 3.091420035, 3.081713773],
   [2.946405865, 2.945975754, 2.948296888],
   [2.761874457, 2.765263397, 2.760575252]]],
 ["vm1_neq",
  [[1.134039524, 1.144053988, 1.13461101],
   [1.143132995, 1.163305096, 1.143727499],
   [1.111422858, 1.132822294, 1.152234176],
   [1.145916448, 1.150504574, 1.138609687]]],
 ["vm1_not",
  [[0.893561863, 0.89357606, 0.891776476],
   [0.91875737, 0.923308629, 0.920428726],
   [0.919896341, 0.915065609, 0.915100837],
   [0.886693527, 0.886190176, 0.889610924]]],
 ["vm1_rescue",
  [[0.759092481, 0.759342884, 0.759245095],
   [0.779441522, 0.780104805, 0.780930914],
   [0.779490299, 0.780039827, 0.779640503],
   [0.744775164, 0.744769599, 0.744298279]]],
 ["vm1_simplereturn",
  [[1.206265083, 1.207515805, 1.219910802],
   [1.238180477, 1.244953274, 1.248884517],
   [1.64187214, 1.640863685, 1.636683486],
   [1.3133721, 1.317810138, 1.319138642]]],
 ["vm1_swap",
  [[0.880896096, 0.876672556, 0.873646364],
   [0.912451664, 0.913062674, 0.915430669],
   [0.932161318, 0.927094527, 0.957684779],
   [0.864081978, 0.864486113, 0.864636167]]],
 ["vm1_yield",
  [[1.262893487, 1.276419238, 1.283607227],
   [1.306593376, 1.328032284, 1.31422982],
   [1.188265239, 1.183254151, 1.184525146],
   [1.338056172, 1.340585393, 1.333406474]]],
 ["vm2_array",
  [[0.874288143, 0.874015975, 0.871460985],
   [0.861476513, 0.865633431, 0.863674112],
   [0.728904874, 0.70332987, 0.727732195],
   [0.863988986, 0.861563981, 0.860761263]]],
 ["vm2_bigarray",
  [[6.821100776, 6.915706147, 7.262702939],
   [10.740991503, 11.172122418, 10.702384827],
   [8.292044822, 8.766247302, 8.298585034],
   [6.619415729, 6.68081791, 6.695559162]]],
 ["vm2_bighash",
  [[5.757441246, 5.804874467, 5.808462803],
   [5.058966834, 5.312727486, 5.052674186],
   [5.272737184, 5.234747717, 5.196921546],
   [5.825274713, 5.902356944, 5.857918796]]],
 ["vm2_case",
  [[0.268417213, 0.268507097, 0.268839224],
   [0.274659667, 0.271154611, 0.271541093],
   [0.312792612, 0.312448731, 0.318117014],
   [0.259396437, 0.262179619, 0.258107754]]],
 ["vm2_defined_method",
  [[3.072929548, 3.081009046, 3.059344045],
   [2.880023904, 2.867644564, 2.864467093],
   [3.493825126, 3.40409348, 3.394098683],
   [3.028583306, 3.014979996, 3.131942448]]],
 ["vm2_dstr",
  [[1.998616849, 2.000880212, 1.990305893],
   [1.600745728, 1.590364401, 1.661487798],
   [2.333501402, 2.317273951, 2.313784883],
   [1.851863922, 1.865102844, 1.855898979]]],
 ["vm2_eval",
  [[15.642602638, 15.304773211, 15.459043563],
   [17.051293951, 16.126888435, 16.988656324],
   [12.61572308, 12.744858869, 12.270834792],
   [15.641400906, 15.436924347, 15.966145433]]],
 ["vm2_method",
  [[1.198099084, 1.188201978, 1.235612262],
   [1.2250654, 1.230205265, 1.247406952],
   [1.830268384, 1.988296474, 1.825144726],
   [1.30971963, 1.312656953, 1.310389838]]],
 ["vm2_method_missing",
  [[2.079806573, 2.052615797, 2.060783485],
   [2.074575985, 2.173368359, 2.102542258],
   [4.125095445, 4.03075505, 4.038664682],
   [2.190290561, 2.152490204, 2.194194022]]],
 ["vm2_method_with_block",
  [[1.4537331, 1.450951909, 1.452868422],
   [1.498316807, 1.469483767, 1.474972516],
   [1.827441319, 1.85967307, 1.82230543],
   [1.544520226, 1.582808759, 1.545401723]]],
 ["vm2_mutex",
  [[0.88527588, 0.884271978, 0.871235841],
   [0.867655352, 0.867586029, 0.848800957],
   [1.058286809, 1.04159052, 1.037831386],
   [0.869592095, 0.870447652, 0.872990696]]],
 ["vm2_poly_method",
  [[2.186947316, 2.179519991, 2.189759818],
   [2.200213983, 2.235718669, 2.22744687],
   [2.449437757, 2.472857786, 2.459590513],
   [2.293849072, 2.241126432, 2.248085544]]],
 ["vm2_poly_method_ov",
  [[0.355108168, 0.359044975, 0.356415969],
   [0.372607894, 0.373988015, 0.375115661],
   [0.364267318, 0.364659838, 0.36261723],
   [0.343648652, 0.341193803, 0.346102468]]],
 ["vm2_proc",
  [[0.627199497, 0.61373327, 0.61402351],
   [0.617743012, 0.595287977, 0.618821465],
   [0.665604933, 0.666784071, 0.674036818],
   [0.634933562, 0.633283009, 0.597343201]]],
 ["vm2_raise1",
  [[6.901207356, 6.764197701, 6.944549246],
   [6.139699901, 6.152858066, 6.12463819],
   [14.226125092, 14.289234802, 14.208513651],
   [7.24430192, 7.215944933, 7.195592247]]],
 ["vm2_raise2",
  [[9.505189419, 9.373688566, 9.824068669],
   [9.0790824, 9.062157371, 9.059955623],
   [39.847553234, 40.066859636, 40.101037147],
   [9.958132085, 9.997546175, 10.15853801]]],
 ["vm2_regexp",
  [[1.330653559, 1.335640029, 1.414009063],
   [1.396003451, 1.399842927, 1.395599231],
   [1.266103704, 1.241384498, 1.25015508],
   [1.322830446, 1.313156547, 1.320252781]]],
 ["vm2_send",
  [[0.46646592, 0.460639701, 0.461177917],
   [0.458428624, 0.462640307, 0.464813666],
   [0.422702659, 0.420901896, 0.419664655],
   [0.456363975, 0.459375416, 0.462872325]]],
 ["vm2_super",
  [[0.547811771, 0.541892969, 0.571267653],
   [0.554027362, 0.547500198, 0.546790028],
   [0.613226172, 0.633516832, 0.611893755],
   [0.565999865, 0.563941148, 0.569990488]]],
 ["vm2_unif1",
  [[0.301481546, 0.299129848, 0.309822083],
   [0.307895147, 0.405163863, 0.301921545],
   [0.381009369, 0.385739537, 0.383167656],
   [0.305110677, 0.305335414, 0.305867819]]],
 ["vm2_zsuper",
  [[0.560940253, 0.581526691, 0.559718381],
   [0.569571949, 0.572774038, 0.565835324],
   [0.635059995, 0.635423184, 0.643495713],
   [0.597480961, 0.587794762, 0.581698298]]],
 ["vm3_backtrace",
  [[0.210785361, 0.208830826, 0.208901973],
   [0.213054421, 0.212734285, 0.213147798],
   [2.49715292, 2.48900489, 2.505606498],
   [0.188435989, 0.188446543, 0.188674263]]],
 ["vm3_clearmethodcache",
  [[0.489506079, 0.488522687, 0.488236333],
   [0.637807478, 0.645163829, 0.636699478],
   [0.360404926, 0.376059481, 0.362159834],
   [0.47238072, 0.468968463, 0.47166797]]],
 ["vm3_gc",
  [[2.127220398, 2.190392536, 2.207169653],
   [2.298974042, 2.351099927, 2.321696636],
   [1.371684676, 1.361009398, 1.377756902],
   [0.759132126, 0.749746738, 0.791810294]]],
 ["vm_thread_alive_check1",
  [[0.144084783, 0.141857283, 0.138871395],
   [0.14303952, 0.136445913, 0.136892722],
   [0.150704841, 0.148676542, 0.148839738],
   [0.134061265, 0.130402532, 0.12696098]]],
 ["vm_thread_create_join",
  [[1.484909564, 1.456710445, 1.482462978],
   [1.481957683, 1.464745206, 1.479011513],
   [1.407045713, 1.385975604, 1.403015744],
   [1.44334212, 1.464553632, 1.441031155]]],
 ["vm_thread_mutex1",
  [[0.661706083, 0.655239639, 0.650353601],
   [0.642376354, 0.663177813, 0.657788643],
   [0.771526368, 0.774828386, 0.775744727],
   [0.6618067, 0.649243243, 0.652589787]]],
 ["vm_thread_mutex2",
  [[2.152157181, 1.022791344, 2.372685178],
   [2.732041626, 0.647916314, 2.076178747],
   [2.399297434, 2.419817615, 2.56450371],
   [2.122212945, 2.276880033, 3.106486969]]],
 ["vm_thread_mutex3",
  [[24.825039158, 23.548028047, 24.813187526],
   [23.87193864, 22.323857467, 25.515747928],
   [1.994415896, 1.970488332, 1.938751228],
   [24.319403997, 25.437533118, 20.687078531]]],
 ["vm_thread_pass",
  [[0.474100852, 0.533051863, 0.450143559],
   [0.468503401, 0.579729039, 0.450585904],
   [0.529511932, 0.48707757, 0.517994803],
   [0.493729446, 0.443490044, 0.417942616]]],
 ["vm_thread_pass_flood",
  [[0.136109911, 0.135562026, 0.130535164],
   [0.485091799, 0.44208715, 0.471618098],
   [0.307770367, 0.251522881, 0.253383106],
   [0.114416791, 0.109460752, 0.119409074]]],
 ["vm_thread_pipe",
  [[0.412041652, 0.402737398, 0.405671865],
   [0.42112308, 0.400260527, 0.425199599],
   [0.681126587, 0.741039475, 0.854447475],
   [0.44066309, 0.424523853, 0.443117426]]],
 ["vm_thread_queue",
  [[0.182447125, 0.170635522, 0.167987649],
   [5.32224477, 5.126583652, 5.591476905],
   [53.438007747, 51.703505298, 51.633497136],
   [0.157051289, 0.159704114, 0.157137553]]]]

Elapsed time: 4048.771281003 (sec)
-----------------------------------------------------------
benchmark results:
minimum results in each 3 measurements.
Execution time (sec)
name	2.1.1p2	2.0.0p376	1.9.3p488	built-ruby
app_answer	0.056	0.054	0.053	0.047
app_aobench	46.180	51.769	90.455	47.893
app_erb	1.054	1.044	1.061	0.969
app_factorial	0.838	1.131	0.962	0.830
app_fib	0.450	0.467	0.633	0.489
app_mandelbrot	1.059	1.129	1.758	1.084
app_pentomino	15.995	16.172	16.164	16.397
app_raise	0.332	0.291	0.429	0.339
app_strconcat	1.261	1.203	1.341	1.252
app_tak	0.657	0.678	0.952	0.699
app_tarai	0.541	0.567	0.753	0.580
app_uri	0.671	0.711	0.635	0.659
hash_flatten	0.677	2.986	3.086	0.660
hash_keys	0.300	3.131	3.015	0.290
hash_shift	0.044	4.919	0.030	0.032
hash_values	0.298	3.099	2.999	0.284
io_file_create	2.046	1.885	1.870	1.912
io_file_read	1.034	2.105	2.129	0.993
io_file_write	0.860	0.845	0.805	0.857
io_select	1.263	1.223	1.098	1.223
io_select2	1.432	1.384	1.275	1.381
io_select3	0.037	0.035	0.023	0.025
loop_for	1.192	1.214	1.297	1.218
loop_generator	0.413	0.413	0.410	0.407
loop_times	1.099	1.113	1.169	1.135
loop_whileloop	0.603	0.621	0.618	0.597
loop_whileloop2	0.139	0.140	0.131	0.129
so_ackermann	0.550	0.579	0.723	0.593
so_array	0.827	1.003	1.238	0.862
so_binary_trees	5.888	6.443	7.908	6.273
so_concatenate	4.240	3.713	3.832	4.435
so_count_words	0.232	0.231	0.227	0.236
so_exception	0.322	0.277	0.854	0.316
so_fannkuch	1.123	1.173	1.181	1.045
so_fasta	1.934	1.976	2.211	1.959
so_k_nucleotide	1.265	1.380	1.432	1.306
so_lists	0.543	0.542	0.767	0.513
so_mandelbrot	2.060	2.089	4.272	2.042
so_matrix	0.571	0.567	0.749	0.561
so_meteor_contest	2.956	3.477	4.130	3.132
so_nbody	1.318	1.363	3.174	1.344
so_nested_loop	1.042	1.051	1.100	1.088
so_nsieve	1.856	2.072	2.508	1.806
so_nsieve_bits	2.265	2.246	2.518	2.263
so_object	0.695	0.762	0.828	0.715
so_partial_sums	1.828	1.852	4.057	1.845
so_pidigits	0.547	0.710	0.612	0.493
so_random	0.510	0.523	0.882	0.516
so_reverse_complement	1.306	1.976	1.823	1.891
so_sieve	0.617	0.709	0.835	0.588
so_spectralnorm	1.843	1.886	3.080	1.982
vm1_attr_ivar*	0.807	0.827	1.703	0.830
vm1_attr_ivar_set*	0.937	1.082	2.039	0.974
vm1_block*	1.413	1.441	1.620	1.618
vm1_const*	0.279	0.297	0.301	0.283
vm1_ensure*	0.053	0.046	0.048	0.046
vm1_float_simple*	4.121	3.889	8.637	4.013
vm1_gc_short_lived*	9.982	10.625	9.748	10.296
vm1_gc_short_with_complex_long*	11.254	14.791	14.248	12.365
vm1_gc_short_with_long*	10.963	10.886	12.938	10.876
vm1_gc_short_with_symbol*	9.700	12.101	15.422	10.736
vm1_gc_wb_ary*	0.670	0.999	1.410	0.668
vm1_gc_wb_obj*	0.635	0.537	1.032	0.627
vm1_ivar*	0.422	0.463	0.352	0.418
vm1_ivar_set*	0.446	0.519	0.414	0.433
vm1_length*	0.605	0.632	0.673	0.600
vm1_lvar_init*	1.364	1.395	1.891	1.233
vm1_lvar_set*	2.179	2.461	2.328	2.164
vm1_neq*	0.531	0.522	0.493	0.542
vm1_not*	0.289	0.298	0.297	0.290
vm1_rescue*	0.156	0.159	0.161	0.148
vm1_simplereturn*	0.604	0.617	1.018	0.717
vm1_swap*	0.271	0.292	0.309	0.268
vm1_yield*	0.660	0.686	0.565	0.737
vm2_array*	0.732	0.721	0.572	0.732
vm2_bigarray*	6.682	10.562	8.161	6.490
vm2_bighash*	5.618	4.912	5.066	5.696
vm2_case*	0.129	0.131	0.181	0.129
vm2_defined_method*	2.920	2.724	3.263	2.886
vm2_dstr*	1.851	1.450	2.182	1.723
vm2_eval*	15.165	15.987	12.139	15.308
vm2_method*	1.049	1.085	1.694	1.181
vm2_method_missing*	1.913	1.934	3.899	2.023
vm2_method_with_block*	1.312	1.329	1.691	1.415
vm2_mutex*	0.732	0.709	0.906	0.741
vm2_poly_method*	2.040	2.060	2.318	2.112
vm2_poly_method_ov*	0.216	0.232	0.231	0.212
vm2_proc*	0.474	0.455	0.534	0.468
vm2_raise1*	6.625	5.984	14.077	7.067
vm2_raise2*	9.234	8.920	39.716	9.829
vm2_regexp*	1.191	1.255	1.110	1.184
vm2_send*	0.321	0.318	0.288	0.327
vm2_super*	0.402	0.407	0.481	0.435
vm2_unif1*	0.160	0.162	0.250	0.176
vm2_zsuper*	0.420	0.426	0.504	0.453
vm3_backtrace	0.209	0.213	2.489	0.188
vm3_clearmethodcache	0.488	0.637	0.360	0.469
vm3_gc	2.127	2.299	1.361	0.750
vm_thread_alive_check1	0.139	0.136	0.149	0.127
vm_thread_create_join	1.457	1.465	1.386	1.441
vm_thread_mutex1	0.650	0.642	0.772	0.649
vm_thread_mutex2	1.023	0.648	2.399	2.122
vm_thread_mutex3	23.548	22.324	1.939	20.687
vm_thread_pass	0.450	0.451	0.487	0.418
vm_thread_pass_flood	0.131	0.442	0.252	0.109
vm_thread_pipe	0.403	0.400	0.681	0.425
vm_thread_queue	0.168	5.127	51.633	0.157

Speedup ratio: compare with the result of `2.1.1p2' (greater is better)
name	2.0.0p376	1.9.3p488	built-ruby
app_answer	1.049	1.068	1.196
app_aobench	0.892	0.511	0.964
app_erb	1.010	0.994	1.089
app_factorial	0.741	0.871	1.009
app_fib	0.965	0.712	0.920
app_mandelbrot	0.938	0.602	0.977
app_pentomino	0.989	0.990	0.975
app_raise	1.139	0.774	0.978
app_strconcat	1.048	0.940	1.007
app_tak	0.969	0.690	0.939
app_tarai	0.953	0.718	0.933
app_uri	0.944	1.057	1.018
hash_flatten	0.227	0.219	1.026
hash_keys	0.096	0.100	1.036
hash_shift	0.009	1.482	1.370
hash_values	0.096	0.099	1.050
io_file_create	1.086	1.094	1.070
io_file_read	0.491	0.486	1.042
io_file_write	1.017	1.068	1.004
io_select	1.032	1.150	1.032
io_select2	1.034	1.123	1.037
io_select3	1.064	1.614	1.490
loop_for	0.982	0.919	0.979
loop_generator	1.001	1.008	1.016
loop_times	0.987	0.939	0.968
loop_whileloop	0.971	0.975	1.010
loop_whileloop2	0.995	1.061	1.081
so_ackermann	0.950	0.760	0.928
so_array	0.824	0.668	0.960
so_binary_trees	0.914	0.745	0.939
so_concatenate	1.142	1.106	0.956
so_count_words	1.008	1.024	0.986
so_exception	1.164	0.377	1.019
so_fannkuch	0.958	0.951	1.075
so_fasta	0.979	0.875	0.987
so_k_nucleotide	0.917	0.884	0.969
so_lists	1.002	0.709	1.059
so_mandelbrot	0.986	0.482	1.009
so_matrix	1.007	0.763	1.019
so_meteor_contest	0.850	0.716	0.944
so_nbody	0.967	0.415	0.980
so_nested_loop	0.992	0.947	0.958
so_nsieve	0.896	0.740	1.028
so_nsieve_bits	1.009	0.900	1.001
so_object	0.913	0.839	0.973
so_partial_sums	0.987	0.451	0.991
so_pidigits	0.770	0.893	1.109
so_random	0.975	0.578	0.989
so_reverse_complement	0.661	0.717	0.690
so_sieve	0.870	0.739	1.049
so_spectralnorm	0.977	0.599	0.930
vm1_attr_ivar*	0.975	0.474	0.973
vm1_attr_ivar_set*	0.866	0.459	0.962
vm1_block*	0.981	0.872	0.873
vm1_const*	0.937	0.925	0.984
vm1_ensure*	1.150	1.104	1.136
vm1_float_simple*	1.060	0.477	1.027
vm1_gc_short_lived*	0.940	1.024	0.970
vm1_gc_short_with_complex_long*	0.761	0.790	0.910
vm1_gc_short_with_long*	1.007	0.847	1.008
vm1_gc_short_with_symbol*	0.802	0.629	0.903
vm1_gc_wb_ary*	0.671	0.475	1.003
vm1_gc_wb_obj*	1.183	0.615	1.012
vm1_ivar*	0.911	1.201	1.011
vm1_ivar_set*	0.858	1.077	1.030
vm1_length*	0.958	0.898	1.009
vm1_lvar_init*	0.978	0.721	1.106
vm1_lvar_set*	0.885	0.936	1.007
vm1_neq*	1.018	1.078	0.980
vm1_not*	0.971	0.974	0.998
vm1_rescue*	0.987	0.971	1.059
vm1_simplereturn*	0.978	0.593	0.842
vm1_swap*	0.930	0.878	1.013
vm1_yield*	0.963	1.169	0.896
vm2_array*	1.015	1.280	1.000
vm2_bigarray*	0.633	0.819	1.029
vm2_bighash*	1.144	1.109	0.986
vm2_case*	0.985	0.712	0.999
vm2_defined_method*	1.072	0.895	1.012
vm2_dstr*	1.276	0.848	1.074
vm2_eval*	0.949	1.249	0.991
vm2_method*	0.967	0.619	0.888
vm2_method_missing*	0.989	0.491	0.945
vm2_method_with_block*	0.987	0.776	0.927
vm2_mutex*	1.033	0.807	0.988
vm2_poly_method*	0.990	0.880	0.966
vm2_poly_method_ov*	0.928	0.933	1.017
vm2_proc*	1.042	0.888	1.013
vm2_raise1*	1.107	0.471	0.937
vm2_raise2*	1.035	0.233	0.939
vm2_regexp*	0.949	1.073	1.006
vm2_send*	1.009	1.114	0.981
vm2_super*	0.990	0.838	0.925
vm2_unif1*	0.987	0.640	0.907
vm2_zsuper*	0.987	0.834	0.928
vm3_backtrace	0.982	0.084	1.108
vm3_clearmethodcache	0.767	1.355	1.041
vm3_gc	0.925	1.563	2.837
vm_thread_alive_check1	1.018	0.934	1.094
vm_thread_create_join	0.995	1.051	1.011
vm_thread_mutex1	1.012	0.843	1.002
vm_thread_mutex2	1.579	0.426	0.482
vm_thread_mutex3	1.055	12.146	1.138
vm_thread_pass	0.999	0.924	1.077
vm_thread_pass_flood	0.295	0.519	1.193
vm_thread_pipe	1.006	0.591	0.949
vm_thread_queue	0.033	0.003	1.070

Log file: bmlog-20140109-134627.2333
